% !TeX root = ../../book.tex
\section{强归纳法}

现在，我们将解释为什么我们之前使用的归纳法被称为``常规''归纳法。接下来，我们将介绍一种称为\textbf{强归纳法}的技术。你会明白这个术语的含义。具体来说，我们会对强归纳法中的归纳假设做出\emph{更强}的假设；简单来说，我们会在证明中假设``更多的东西''，这使我们更容易（有时仅仅是能够）得出结论。本节的重要部分，除了通过几个例子来掌握这种改进后的技术之外，还将实际\emph{证明}这种更强的技术的有效性。为此，我们将使用数学归纳法本身！

\subsection{动机}

回顾一下 \ref{sec:section2.4} 节的例子。在那里，我们考察了用多米诺骨牌密铺 $2 \times n$ 矩形棋盘的方法数量，并且我们玩了取走游戏。在处理这些例子的归纳论证时，我们发现情况与之前的归纳论证略有不同。当我们证明类似于
\[\sum_{k=1}^{n} \frac{n(n+1)}{2}\]
对于每个 $n \in \mathbb{N}$ 都成立，我们可以在归纳步骤中引用前一个情况并调用归纳假设，如下所示：
\[\sum_{k=1}^{n+1} k=(n+1)+\sum_{k=1}^{n}k = n+1+\frac{n(n+1)}{2} = \frac{(n+1)(n+2)}{2} \]
当然，我们当时没有把这些部分称为``\textbf{归纳假设（IH）}''或``\textbf{归纳步骤（IS）}''，但这正是我们接下里要做的事情。

然而，当我们思考多米诺密铺的例子时，我们发现需要引用前两个实例的事实。具体来说，要找到一个 $2 \times n$ 棋盘的密铺数量，我们不仅需要知道 $2 \times (n-1)$ 棋盘的密铺数量，还需要知道 $2 \times (n-2)$ 棋盘的密铺数量。这本质上是不同的！归纳论证的什么特性让我们能够这样做？这如何遵循我们描述的``多米诺类比''？或者``猴子 Mojo 类比''？它是否真的遵循？

当我们思考取走游戏时，情况甚至``更为''不同，不是吗？在制定玩家 $2$ 的获胜策略时，我们注意到玩家 $2$ 应该在另一堆上模仿玩家 $1$ 的动作。也就是说，如果玩家 $1$ 从左边的堆中移走 $3$ 块石头，那么玩家 $2$ 应该从右边的堆中移走 $3$ 块石头，以保证胜利。这在无论玩家 $1$ 移走多少石头的情况下都成立。从这个意义上讲，我们需要玩家 $2$ 在任意大小的堆（包括 $n$）上都有必胜策略，以保证玩家 $2$ 在大小为 $n + 1$ 的堆上有获胜策略。这需要在我们的归纳假设中包含很多假设。我们怎么知道我们可以这样做？

\subsection{定理陈述与证明}\label{sec:section5.4.2}

我们的目标是陈述并证明一个改进版的数学归纳原理，能够反映多米诺骨牌覆盖和取走游戏这类例子。它们代表了一种归纳论证，其中我们可能需要
\begin{enumerate}[label=(\arabic*)]
    \item 引用多个先前实例来证明声明的后续实例；
    \item 引用某个未知的先前实例来证明后续实例。
\end{enumerate}
这个定理将涵盖这两种风格的论证。首先让我们看看定理的陈述，然后讨论它的含义。

\begin{theorem}[强数学归纳原理（Strong PMI）]\label{theorem5.4.1}
    设 $P(n)$ 为变量命题，假设
    \begin{enumerate}[label=(\arabic*)]
        \item $P(1)$ 成立
        \item $\forall k \in \mathbb{N} \centerdot \big(\forall i \in [k] \centerdot P(i)\big) \implies P(k+1)$ 成立
    \end{enumerate}
    则 $\forall n \in \mathbb{N} \centerdot P(n)$ 成立。
\end{theorem}

哇哦，这是什么意思？我们在这里以逻辑符号的形式呈现定理，然后再以更详细的方式讨论，这样做可能会给你增加了一些额外工作，但我们认为你应该可以应付过来。尽管条件 (2) 显然比较难一些，但请试着解析这两个条件。它说了什么？大声读出来，用一句话写下来，思考一下。将它与我们在上一节中陈述和证明的常规数学归纳原理比较一下。为什么我们称此为`'`强归纳法''？这些定理有何不同？它们的假设不同吗？它们的结论呢？花几分钟时间思考这些问题。然后再继续阅读……

好的，让我们来解释一下这个定理。请注意，\textbf{强归纳法}（定理 \ref{theorem5.4.1}）和\textbf{常规归纳法}（定理 \ref{theorem5.2.2}）之间的\emph{唯一}区别在于条件 (2)，它决定了我们在证明的归纳假设部分要做什么。设定（我们有一个变量命题）和条件 (1)（基本情况）以及结论（对于每个 $n \in \mathbb{N}, P(n)$ 都成立）是相同的。现在让我们比较一下条件 (2)。

常规归纳法要求对于每个 $k \in \mathbb{N}, P(k)$ 足以让我们推导出 $P(k+1)$。如果我们能做到这一点（多米诺骨牌效应），并且我们有一个基本情况，那么 $P(n)$ 对于每个 $n \in \mathbb{N}, P(n)$ 都成立。这就是我们在归纳假设和归纳步骤中所做的：假设 $P(k)$ 成立，并使用它推导出 $P(k + 1)$ 必然成立。

让我们重写强归纳法的条件 (2) 来看看它说了什么：
\[\forall k \in \mathbb{N} \centerdot \big(P(1) \land P(2) \land P(3) \land \dots \land P(k)) \implies P(k+1)\]
也就是说，强归纳法要求所有之前的命题实例（$P(1), P(2), (3), \dots$ 一直到 $P(k)$）一起才足以让我们推导出 $P(k+1)$。这个定理似乎在说，``嘿，不用担心只能通过 $P(k)$ 来得到 $P(k+1)$; 实际上你可以使用从 $P(1)$ 到 $P(k)$ 的所有陈述来得到 $P(k+1)$ 成立！所需的结论 --- $\forall n \in \mathbb{N} \centerdot P(n)$ --- 仍然成立！'''是不是很棒？

现在有三方面需要讨论：
\begin{enumerate}[label=(\arabic*)]
    \item 为什么这种方法是有效的；
    \item 什么时候需要使用它；
    \item 如何使用它。
\end{enumerate}
我们先快速解决问题 (3)，然后再给你展示一些例子。强归纳法证明和常规归纳法证明之间的唯一区别将在于\textbf{归纳假设}和\textbf{归纳步骤}。当使用强归纳法时，在归纳假设中我们假设 $P(1), P(2), \dots$ 直到 $P(k)$ 都成立，然后使用它们来推导出 $P(k+1)$ 必然成立。在归纳步骤中，我们只需要小心指出我们使用了归纳假设的哪些假设。

为了解决问题 (2) --- 何时使用强归纳法 --- 我们将展示几个例子。在处理这些例子时，我们将准确指出为什么常规归纳法证明会失效。通过研究这些实例，我们希望能培养出在未来识别这些情况的直觉。也就是说，我们将学习到哪些类型的声明在其证明中需要强归纳假设。

再来看问题 (1)，因为这是最紧迫的。在我们快速上手并开始使用某个证明技术之前，我们要确保它在数学上是有效的！如果你像我们一样，你会想，``这个定理怎么可能是真的？它说我们需要知道更多 $P(n)$ 实例之间的关系。为什么我们允许在归纳假设中做出这么多假设并能够在以后使用它们？''

\subsubsection*{改良版多米诺骨牌类比与启发图}

我们先从改进第 \ref{ch:chapter02} 章中的多米诺骨牌类比开始，然后展示一个关于强归纳法如何工作的\textbf{启发图}，以便你能够更好地理解。之后，我们将严格证明上述定理。

回想一下常规归纳法是如何遵循多米诺骨牌类比的。我们只需要知道多米诺骨牌 $n$ 会倒向多米诺骨牌 $n+1$，就能保证整个队列会倒下。而在强归纳法中，我们需要知道包括多米诺骨牌 $n$ 在内的所有多米诺骨牌都已经倒下，并且撞向多米诺骨牌 $n+1$，将其撞倒，这样才能保证整个队列倒下。这就好像随着队列的延续，多米诺骨牌变得越来越重，因此需要一连串的多米诺骨牌相互撞击才能够产生足够的动量，推倒下一个更重的多米诺骨牌。

换一种方式来解释。想象一下连接我们所有命题的推理链。\textbf{基本情况（BC）}会告诉我们 $P(1)$ 为\verb|真|。这就意味着 $P(2)$ 成立。（在强数学归纳原理的条件 (2) 中应用 $n = 1$。）知道这两个命题成立意味着 $P(3)$ 成立。（在强数学归纳原理的条件 (2) 中应用 $n=2$。）知道这三个命题成立将意味着 $P(4)$ 成立。依此类推：
\[\underbrace{\underbrace{\overbrace{\Big(P(1)\Big)}^{\text{基本情况为真}} \overbrace{\implies}^{\text{应用归纳步骤}} \overbrace{\Big(P(2)\Big)}^{\text{为真}}}_{\text{已知 } P(1) \land P(2)} \underbrace{\implies}_{\text{应用归纳步骤}} \underbrace{\Big(P(3)\Big)}_{\text{为真}}}_{\text{已知 } P(1) \land P(2) \land P(3)} \implies\Big(P(4)\Big) \implies \Big(P(5)\Big)\]
在某种程度上，这说明了为什么这种方法总体上是有效的。我们证明了 $P(1)$ 成立，就像常规归纳法一样。但随后，为了``得出'' $P(2)$ 的真值，第一步--- $P(1) \implies P(2)$ ---在强归纳法和常规归纳法中是一样的。（在强数学归纳原理和数学归纳原理的条件 (2) 中应用 $n = 1$。这种情况下二者是相同的。）从此刻开始，当我们使用强归纳法时，我们只是利用了所有先前命题都成立的事实；我们不妨利用它们来继续推导下一个命题的真值！常规归纳法不关注这一点。它说，``好吧，很好，所有先前的实例都成立。我们实际上不需要它们来证明下一个实例；我们只需要紧接着的前一个实例。''

这里有另一种稍微不同的方式来解释这种``推理链''。这实际上也直接暗示了我们很快将看到的证明！假设我们正在进行强归纳过程，并且我们已经证明了直到 $P(n)$ 的所有内容；也就是说，$P(1), P(2),\dots$ 直到 $P(n)$ 都是为\verb|真|。让我们把这些实例打包在一起，并将它们标记为一个大命题 $Q(n)$。（换一种方式思考，我们将所有这些多米诺骨牌绑定在一起，变成一个巨大的多米诺骨牌。）下一步是使用此实例来证明下一个实例，这听起来更像是我们熟悉的常规归纳法。这基本上就是我们要在证明中做的事情！我们将重新构建整个强归纳法过程，使其表述为一个常规归纳法过程。

\subsubsection*{严格证明}

正如前文所提到的，接下来的证明将运用数学归纳原理（PMI）。 （事实上，我们还会使用上一节中讲解的归纳证明模板！）从这个角度来看，我们实际上是在证明这个命题：
\[\text{PMI} \implies \text{SPMI}\]
让我们开始吧！

\begin{proof}
    设 $P(n)$ 为变量命题，假设
    \begin{enumerate}[label=(\arabic*)]
        \item $P(1)$ 成立
        \item $\forall k \in \mathbb{N} \centerdot \big(\forall i \in [k] \centerdot P(i)\big) \implies P(k+1)$ 成立
    \end{enumerate}
    我们的目标是证明 $\forall n \in \mathbb{N} \centerdot P(n)$。

    定义命题 $Q(n)$ 为
    \[Q(n) \iff \forall i \in [n] \centerdot P(i)\]
    （也就是说，$Q(n)$ 表示所有命题 $P(1), P(2), \dots$ 直到 $P(n)$ 都为\verb|真|。）

    我们通过对 $n$ 应用归纳法来证明 $\forall n \in \mathbb{N} \centerdot Q(n)$。

    \textbf{基本情况}：根据命题 $Q(n)$ 的定义，我们有 $Q(1) \iff P(1)$。条件 (1) 告诉我们 $P(1)$ 成立，那么 $Q(1)$ 也一定成立。

    \textbf{归纳假设}：设 $k \in \mathbb{N}$ 是任意固定的，假设 $Q(k)$ 成立。

    \textbf{归纳步骤}：根据 $Q(n)$ 的定义，我们有
    \[Q(n) \iff \forall i \in [k] \centerdot P(i)\]
    （再次强调，这说明 $P(1), P(2), \dots$ 直到 $P(k)$ 都成立。）

    根据条件 (2) 我们可以推导出 $P(k+1)$ 成立。

    这意味着 $\forall i \in [k+1] \centerdot P(i)$（也就是说我们以前知道 $P(1), P(2), \dots$ 直到 $P(k)$ 都成立，现在我们得到 $P(k+1) 也成立$）。

    根据 $Q(k+1)$ 的定义，这意味着 $Q(k+1)$ 成立。而这正是归纳步骤的目标。

    因此，根据数学归纳原理（PMI），我们推导出 $\forall n \in \mathbb{N} \centerdot Q(n)$ 成立。

    根据 $Q(n)$ 的定义，我们有
    \[\forall n \in \mathbb{N} \centerdot Q(n) \implies P(n)\]
    （也就是说，$Q(n)$ 表示 $P(1), \dots$ 到 $P(n)$ 的所有实例都成立，那么最后一个实例 $P(n)$ 显然成立。）

    由于我们刚刚证明了 $Q(n)$ 对于每个 $n \in \mathbb{N}$ 都成立，因此我们可以推断 $P(n)$ 对于每个 $n \in \mathbb{N}$ 也成立，即
    \[\forall n \in \mathbb{N} \centerdot P(n)\]
    这就是我们要证的目标，所以证明完毕。
\end{proof}

\subsubsection*{证明总结和惊人的等价性}

看看我们完成了什么：我们用常规归纳法证明了强归纳法是有效的。这表明数学归纳原理（PMI）定理\emph{蕴含}强数学归纳原理（SPMI）定理：
\[\text{PMI} \implies \text{SPMI}\]

当然，这也可以反过来！如果我们已经通过其他方法证明了强归纳法的有效性，那么普通归纳法也必然是有效的。也就是说，我们还知道：
\[\text{SPMI} \implies \text{PMI}\]
换句话说：如果我们已经掌握了强归纳法作为一种有效的证明技术，那么每当我们想用常规归纳法证明某事时，我们只需使用强归纳法来实现我们的目标。从这个意义上讲，强归纳法``包含''了常规归纳法。

这两个观察结果共同告诉我们关于数学归纳原理（PMI）和强数学归纳原理（SPMI）在数学世界中的一个重要事实。我们现在已经证明它们是等价的：
\[\text{PMI} \iff \text{SPMI}\]
每个定理都蕴含着另一个定理。

现在，出于将这些技术应用于证明的实际目的，这种等价性可能看起来不太重要，但它确实告诉我们一些有用的信息，即：
\begin{quotation}
    \emph{每当我们需要通过归纳法来证明某个命题时，我们最好总是使用强归纳法。}
\end{quotation}

思考几分钟。阅读定理陈述及其证明并考虑一下。在接下来的例子中牢记这一点。等你你学习了下面的证明模板，请回到前一节关于常规归纳法的例子并尝试应用强归纳法。它有效吗？看起来有什么不同吗？试试看！我们将在下面的例子中讨论常规/强归纳法的比较，所以让我们继续看看如何使用强归纳法。

\subsection{使用强归纳法：证明模板}

该模板与常规归纳法的模板非常相似，因为这两个定理（以及相应的应用技术）之间的唯一区别在于归纳假设（IH）。

\subsubsection*{\textcolor{blue}{``强归纳证明''模板}}

\setlength{\fboxrule}{2pt}
\setlength\fboxsep{5mm}
\begin{center}
\noindent \fcolorbox{blue}{white}{%
    \parbox{0.85\textwidth}{%
        \linespread{1.5}\selectfont
        \textbf{目标：} 证明 $\forall n \in \mathbb{N} \centerdot P(n)$
        \begin{proof}\\
            设 $P(n)$ 为命题 ``$\underline{\qquad\qquad\qquad}$''。\\
            我们对 $n$ 采用归纳法证明 $\forall n \in \mathbb{N} \centerdot P(n)$。\\
            \textbf{基本情况}：$P(1)$ 成立，因为 $\underline{\qquad\qquad\qquad}$。\\
            \textbf{归纳假设}：设 $k \in \mathbb{N}$ 是任意固定的，假设 $\forall i \in [k] \centerdot P(k)$ 成立。\\
            \textbf{归纳步骤}：推导出 $P(k+1)$ 也成立。\\
            根据数学归纳原理可得$\forall n \in \mathbb{N} \centerdot P(n)$。
        \end{proof}
    }
}
\end{center}

我们对常规归纳法所做的所有重要观察和建议在这里同样适用。我们必须确保定义一个命题，指出我们在特定变量上应用（强）归纳法，标记我们的步骤，并得出结论。

我们想要提出的一个新建议是对旧建议的改进。在使用常规归纳法时，我们必须确保在使用归纳假设（IH）时引用它。在这里，我们的归纳假设中会有许多命题实例，所以我们必须小心，引用证明中使用到的命题实例！你会在下面的例子中看到这一点。

\subsection{示例}

我们将在这里看到三种不同``类型''的例子。尽管它们都使用我们刚刚介绍的强归纳法模板，但它们在引用归纳假设（IH）中的假设时有所不同。第一个例子是强归纳法的直接应用，所以让我们先来看看它，然后讨论其他例子有什么不同。\\

\begin{example}[递归定义数列的公式]
    
    \textbf{声明}：序列 $S_n$ 定义为
    \[s_0 = 1 \;\text{ 且 }\; \forall n \in \mathbb{N} \centerdot s_n = 1 + \sum_{i=0}^{n-1} s_i\]
    对于每个 $n \in \mathbb{N} \cup \{0\}$，找到并证明 $s_n$ 的封闭公式。
\end{example}

\begin{proof}
    令 $P(n)$ 为 ``$s_n = 2^n$''。我们通过对 $n$ 应用归纳法来证明 $n \in \mathbb{N} \cup \{0\} \centerdot P(n)$。

    \textbf{基本情况}：当 $n=0$ 时，不难得到 $s_0=1$ 且 $2^0=1$，所以 $s_0=2^0$，因此 $P(0)$ 成立。

    \textbf{归纳假设}：设 $k \in \mathbb{N} \cup \{0\}$ 是任意固定的，假设 $P(0) \land P(1) \land \dots \land P(k)$ 成立。

    \textbf{归纳步骤}：不难得到

    \begin{align*}
        s_{k+1} &= 1+\sum_{i=0}^{k} s_i & s_{k+1}\text{ 的定义}\\
        &= 1+\sum_{i=0}^{k} 2^i & \text{利用归纳假设：}P(0) \land P(1) \land \dots \land P(k)\\
        &= 1 + (2^{k+1}-1) & \text{标准答案（见练习 } \ref{ex:exercises2.7.1} \text{）}\\
        &= 2^{k+1}
    \end{align*}

    因此 $P(k+1)$ 成立。所以，根据归纳法 $\forall n \in \mathbb{N} \cup \{0\} \centerdot P(n)$ 成立。
\end{proof}

请注意，这个例子要求我们使用归纳假设（IH）中的所有实例。是不是很惊人？确实，我们在这里需要强归纳法。如果不知道之前的所有实例是否成立，我们就无法推导出下一个实例！

与下一个例子不同的是，在这个例子中，我们确切知道使用了归纳假设（IH）的哪些实例（即全部实例）。而在下一个例子中，我们将也会使用归纳假设（IH），但无法确切地指出使用了哪个实例。你会明白我们的意思的！\\

\begin{example}
    首先，我们需要向你介绍（或者提醒你）一些关于质数和自然数的概念。

    \textbf{质数}：\textbf{质数}是下面集合的元素
    \[P = \{n \in \mathbb{N} \mid n > 1 \land (n = ab) \implies (a = 1 \lor a = n)\}\]
    也就是说，质数的因子只有 $1$ 和它本身。

    \textbf{质因数分解}：给定 $x \in \mathbb{N}$，$x$ 的\textbf{质因数分解}为一组质数的乘积，可以重复，乘积的结果等于 $x$。

    例如，$6$ 的质因数分解为 $2 \cdot 3$，$252$ 的质因数分解为 $2 \cdot 2 \cdot 3 \cdot 3 \cdot 7$。

    我们接下来将陈述并证明每个自然数都有一个质因数分解。

    \textbf{声明}：令 $F(n)$ 为命题 ``$n$ 由质因数分解''。我们声明 $\forall n \in \mathbb{N} - \{1\} \centerdot F(n)$。
\end{example}

\begin{proof}
    我们通过对 $n$ 应用归纳法来证明 $\forall n \in \mathbb{N} - \{1\} \centerdot F(n)$。

    \textbf{基本情况}：$F(2)$ 成立，因为 $2 = 2$ 是自然数 $2$ 的质因数分解。

    \textbf{归纳假设}：设 $k \in \mathbb{N} - \{1\}$ 是任意固定的，假设 $\forall i \in [k]-\{1\} \centerdot F(i)$ 成立。（也就是说，假设 $F(2) \land F(3) \land \dots \land F(k)$ 成立。）

    \textbf{归纳步骤}：考虑 $k+1$。我们想要找到 $k+1$ 的质因数分解。根据 $k+1$ 本身是否为质数，有两种情况：

    \textbf{情况 1}：如果 $k+1$ 本身是一个质数，则 $k+1$ 是 $k+1$ 的质因数分解，从而证明 $F(k+1)$ 成立。

    \textbf{情况 2}：如果 $k+1$ 不是质数，则存在 $a, b \in \mathbb{N} - \{1\}$ 使得 $k+1 = a \cdot b$。由于 $a, b \neq 1$，所以必定有 $1 < a < k+1$ 且 $1 < b < k+1$。即 $2 \le a \le k$ 且 $2 \le b \le k$。

    因此，根据归纳假设，$F(a)$ 和 $F(b)$ 成立。也就是说 $a$ 和 $b$ 都存在质因数分解。将这两个质因数分解相乘就得到 $a \cdot b = k+1$ 的质因数分解。这表明 $F(k+1)$ 成立。

    无论是上面哪种情况，我们都推导出 $F(k+1)$ 成立。

    根据归纳法，我们得到 $\forall n \in \mathbb{N} - \{1\} \centerdot F(n)$。
\end{proof}

注意，在这个证明中我们应用了归纳假设（IH），但我们并不知道具体引用的是哪个``之前的实例''。我们只能依赖某个具有特定属性的 $a$ 和 $b$。这与之前的例子不同，但清楚表明我们这里需要使用强归纳法。关于 $k$ 的质因数分解无法帮助我们找到 $k+1$ 的质因数分解。想一想：知道 $14 = 2 \cdot 7$ 能帮助我们得到 $15 = 3 \cdot 5$ 吗？知道 $16 = 2^4$ 能帮助我们得到 $17$ 是质数吗？

我们刚刚证明的这个结果非常重要：它表明每个自然数都有一个质因数分解。质因数分解的\textbf{唯一性}也成立，即每个自然数都\emph{有且只有}一个质因数分解。当然，因数分解与``因数的顺序''无关。也就是说，$6 = 2 \cdot 3$ 和 $6 = 3 \cdot 2$ 实际上是相同的因数分解。同样地，$252 = 2 \cdot 2 \cdot 3 \cdot 3 \cdot 7$ 是 $252$ 的唯一分解；这与写作 $252 = 7 \cdot 3^2 \cdot 2^2$ 没有区别。

然而，上述证明中没有涉及这一事实！我们只是利用了某个 $a$ 和 $b$ 的存在来推导出一些结论。谁能说我们不能用具有相同属性的其他 $c$ 和 $d$ 呢？想一想。你能证明质因数分解的唯一性吗？你会使用什么方法？

下一个例子将涉及\textbf{斐波那契数列}，这是我们之前讨论过的数列。具体来说，我们将陈述并证明该数列的\textbf{封闭形式}，斐波那契数列通常是递归定义的。所谓``封闭形式''，指的是可以直接代入并计算的表达式。例如，要找到 $f_100$，使用递归定义的数列，我们必须计算到那一点为止的所有数列：我们需要 $f_99$ 和 $f_98$，这意味着我们需要 $f_97$，这意味着……然而，通过封闭形式，我们只需``代入 $n$''从而直接计算出 $f_100$。\\

\begin{example}[斐波那契数列的封闭形式]

    \textbf{声明}：斐波那契数列的标准定义如下：
    \[f_0 = 0 \;\text{ 且 }\; f_1 = 1 \;\text{ 且 }\; \forall n \in \mathbb{N}-\{1\} \centerdot f_n = f_{n-1} + f_{n-2}\]
    定义 $\varphi = \frac{1+\sqrt{5}}{2}$。则下面等式对于所有 $n \in \mathbb{N}-\{1\}$ 都成立：
    \[f_n = \frac{1}{\sqrt{5}}\big(\varphi^n-(1-\varphi)^n\big)\]
\end{example}

\begin{proof}
    设 $f_n$ 和 $\varphi$ 如声明所定义。

    我们首先证明下面的等式成立：
    \[1+\varphi=\varphi^2 \tag{*1}\]
    不难发现
    \begin{align*}
        \varphi^2 &= \Big(\frac{1+\sqrt{5}}{2}\Big)^2 = \frac{1+2\sqrt{5}+5}{4} = \frac{6+2\sqrt{5}}{4} \\
        &= \frac{3+\sqrt{5}}{2} = 1+\frac{1+\sqrt{5}}{2} = 1+\varphi \\
    \end{align*}
    接着，我们利用这个等式证明下面的等式：
    \[2-\varphi=(1-\varphi)^2 \tag{*2}\]
    利用 (*1) 的结论，很容易推出
    \[(1-\varphi)^2 = 1-2\varphi+\varphi^2 = 1-2\varphi+(\varphi+1) = 2-\varphi\]

    令 $P(n)$ 为命题
    \[f_n = \frac{1}{\sqrt{5}}\big(\varphi^n-(1-\varphi)^n\big)\]
    我们通过对 $n$ 应用归纳法来证明 $\forall n \in \mathbb{N} \cup \{0\} \centerdot P(n)$。

    \textbf{基本情况}：$f(0) = 0$ 且
    \[\frac{1}{\sqrt{5}}\big(\varphi^0-(1-\varphi)^0\big) = \frac{1}{\sqrt{5}} (1-1) = 0\]
    因此，$P(0)$ 成立。

    \textbf{归纳假设}：设 $k \in \mathbb{N} \cup \{0\}$ 是任意固定的，假设 $\forall i \in [k] \cup \{0\} \centerdot P(i)$ 成立。

    \textbf{归纳步骤}：我们的目标是推导出 $P(k+1)$ 成立。

    \textbf{情况 1}：假设 $k=0$，我们可以很容易推导出 $f_1=1$ 且
    \[\frac{1}{\sqrt{5}}\big(\varphi^1-(1-\varphi)^1\big) = \frac{1}{\sqrt{5}} (2\varphi-1) = \frac{1}{\sqrt{5}} (1+\sqrt{5}-1) = \frac{1}{\sqrt{5}} (\sqrt{5}) = 1\]
    这表明 $P(1)$ 成立。
    \textbf{情况 2}：假设 $k \ge 1$，则
    \begin{align*}
        f_{k+1} &= f_k+f_{k-1} & \text{因为 } k \ge 1, \textbf{ 根据定义} \\
        &= \frac{1}{\sqrt{5}}\big(\varphi^k-(1-\varphi)^k\big) + \frac{1}{\sqrt{5}}\big(\varphi^{k-1}-(1-\varphi)^{k-1}\big) & \text{归纳假设 } P(k), P(k-1)\\
        &= \frac{1}{\sqrt{5}}\big(\varphi^k+\varphi^{k-1}-(1-\varphi)^k-(1-\varphi)^{k-1}\big) & \textbf{化简}\\
        &= \frac{1}{\sqrt{5}}\big(\varphi^{k-1}(\varphi+1)-(1-\varphi)^{k-1}((1-\varphi)+1)\big) & \textbf{提取公因式}\\
        &= \frac{1}{\sqrt{5}}\big(\varphi^{k-1} \cdot \varphi^2-(1-\varphi)^{k-1}(2-\varphi)\big) & \textbf{根据(*1)}\\
        &= \frac{1}{\sqrt{5}}\big(\varphi^{k+1} -(1-\varphi)^{k-1}(1-\varphi)^2\big) & \textbf{根据(*2)}\\
        &= \frac{1}{\sqrt{5}}\big(\varphi^{k+1} -(1-\varphi)^{k+1}\big) & 
    \end{align*}
    因此, $P(k+1)$ 成立。

    根据归纳法，我们得出 $\forall n \in \mathbb{N} \cup \{0\} \centerdot P(n)$。
\end{proof}

\subsubsection*{多基本情况讨论}

注意，在前面的例子中，我们需要在归纳步骤（IS）中考虑两种情况。由于斐波那契数列是递归定义的，每一项都依赖于前两项，所以我们不能仅凭 $P(0)$ 成立来推导出 $P(1)$ 成立。我们必须单独证明 $P(1)$ 成立。（你可以回头试试，你会发现自己不得不引用 $f_{-1}$，这是一个未定义的项！）接下来，我们可以利用 $P(0)$ 和 $P(1)$ 成立来推导出 $P(2)$，然后再用 $P(1)$ 和 $P(2)$ 来推导出 $P(3)$ ……也就是说，我们确实需要在整个归纳法的推理开始之前，添加一个额外的基本情况。

处理这个问题有两种合法的方法，我们刚刚展示了其中一种。另一种方法是提前认识到这种情况，并在基本情况步骤中提出两个基本情况。为了说明这一点，让我们展示一下如果我们采用第二种方法，证明的相关部分会有什么不同：

\begin{proof}

    $\dots$

    $\dots$

    \textbf{基本情况}：$f(0) = 0$ 且
    \[\frac{1}{\sqrt{5}}\big(\varphi^0-(1-\varphi)^0\big) = \frac{1}{\sqrt{5}} (1-1) = 0\]
    因此，$P(0)$ 成立。

    并且 $f(1) = 1$ 且
    \[\frac{1}{\sqrt{5}}\big(\varphi^1-(1-\varphi)^1\big) = \frac{1}{\sqrt{5}} (2\varphi-1) = \frac{1}{\sqrt{5}} (1+\sqrt{5}-1) = \frac{1}{\sqrt{5}} (\sqrt{5}) = 1\]
    因此，$P(1)$ 成立。

    \textbf{归纳假设}：设 $k \in \mathbb{N}$ 是任意固定的，假设 $\forall i \in [k] \cup \{0\} \centerdot P(i)$ 成立。

    \textbf{归纳步骤}：我们的目标是推导出 $P(k+1)$ 成立。

    $\dots$

    $\dots$
\end{proof}

我们将特殊的 $P(1)$ 情况移到了基本情况（BC）部分。因此，我们必须修改归纳假设和归纳步骤中的量化过程。在随后的论证中，我们不再使用 $k = 0$，因此在归纳假设中，我们只取任意满足 $k \ge 1$ 的 $k$。然而，我们已经知道 $P(0)$ 成立，所以我们仍然可以在归纳假设中包含它。

就是这样！这两个证明在本质上是相同的。唯一的区别在于它们的呈现方式，即使如此，这些区别也很小。你可以自由决定在你的证明中更喜欢使用哪种风格（如果有的话）。不过，我们想提醒你，这些区别虽然很小，但也很微妙，有时容易被忽略！如果你发现自己包含了许多基本情况，请确保在开始你的归纳步骤时，寻求证明一个高于这些基本情况的值！你不希望无意中断言某些实际上并不成立的逻辑推论。（例如，回顾上面的第二个证明。如果我们允许 $k = 0$ 作为归纳步骤中的一个情况，我们将无意中引用 $f_{-1}$，而它并不存在。因此，我们会说一些不正确的话，证明将是有缺陷的，尽管不会完全失败。）

这种区别通常发生在你被要求证明某个递归定义数列的表达式时，其中序列中的每一项由几个前面的项定义。本节和本章末尾的练习中有许多这种类型的例子。在做这些练习时请牢记这一点！

\subsubsection*{需要证明 $n=2$ 的情况}

在强归纳法的证明中，常常需要先证明 $n = 1$ 和 $n = 2$ 的情况再进行归纳假设。特别是，当你需要证明某个不等式或等式对 $n$ 个变量成立时，$n = 1$ 的情况通常比较简单，而 $n = 2$ 的情况则更为复杂，需要更多的工作。然后，剩下的归纳证明则可以通过引用 $n = 2$ 的情况来完成。当然，这意味着在归纳假设中需要取 $k \ge 2$。

我们来看一个例子来说明这个问题。幸运的是，我们已经证明了这个命题在 $n = 2$ 的情况下成立；实际上，它就是集合的德摩根定律之一！\\

\begin{example}[集合的广义德摩根定律：]

    \textbf{声明}：设 $U$ 为全集。对于每个 $i \in \mathbb{N}$，设 $A_i \subseteq U$ 为集合。则下面等式等于所有 $n \in \mathbb{N}$ 成立：
    \[\overline{\bigcup_{i=1}^{n} A_i} = \bigcup_{i=1}^{n} \overline{A_i}\]
    换种写法，该声明说的是对于所有 $n \in \mathbb{N}$
    \[\overline{A_1 \cup A_2 \cup \dots \cup A_n} = \overline{A_1} \cap \overline{A_2} \cap \dots \cap \overline{A_n}\]
\end{example}

\begin{proof}
    设 $U$ 和 $A_1, A_2, \dots$ 如声明定义。

    设 $P(n)$ 为命题
    \[\overline{\bigcup_{i=1}^{n} A_i} = \bigcup_{i=1}^{n} \overline{A_i}\]
    我们通过对 $n$ 应用归纳法来证明 $\forall n \in \mathbb{N} \centerdot P(n)$。

    \textbf{基本情况}：显然 $\overline{A_1} = \overline{A_1}$，所以 $P(1)$ 成立。

    并且根据集合的德摩根定律（见定理 \ref{theorem4.6.9}）我们有 $\overline{A_1 \cup A_2} = \overline{A_1} \cap \overline{A_2}$，所以 $P(2)$ 成立。

    \textbf{归纳假设}：设 $k \in \mathbb{N}-\{1\}$ 是任意固定的，假设 $\forall i \in [k] \centerdot P(i)$ 成立。

    \textbf{归纳步骤}：我们的目标是推导出 $P(k+1)$ 成立。

    首先，根据并集的定义，我们有
    \[\bigcup_{i=1}^{k+1} A_i = A_{k+1} \cup \bigcup_{i=1}^k A_i\]

    不妨设
    \[B_k = \bigcup_{i=1}^k A_i\]

    则
    \begin{align*}
        \overline{\bigcup_{i=1}^{k+1} A_i} &= \overline{A_{k+1} \cup B_k} & \text{根据 } B_k \text{ 的定义} \\
        &= \overline{A_{k+1}} \cap \overline{B_k} & \text{根据基本情况 } P(2) \text{（即德摩根定律）}\\
        &= \overline{A_{k+1}} \cap \overline{\bigcup_{i=1}^k A_i} & \text{根据 } B_k \text{ 的定义} \\
        &= \overline{A_{k+1}} \cap \bigcap_{i=1}^k \overline{A_i} & \text{根据归纳假设 } P(k) \\
        &= \bigcap_{i=1}^{k+1} \overline{A_i} & \text{化简}
    \end{align*}

    因此 $P(k+1)$ 成立。

    根据归纳法，$\forall n \in \mathbb{N} \centerdot P(n)$。
\end{proof}

\subsection{比较``常规''归纳法和强归纳法}

我们想再次强调一下之前介绍强归纳法时提到的一个关键点。这是一个重要的教训，值得在这里重申：

\begin{quotation}
    \emph{每当我们需要通过归纳法来证明某个命题时，我们最好总是使用强归纳法。}
\end{quotation}

原因在于，常规归纳法和强归纳法是互相包含的；每一种方法都意味着另一种方法。在进行归纳证明时，使用强归纳假设``没有坏处''，因为我们知道这样做是可以的。在进行证明时，你可能无法预见归纳步骤中需要引用\emph{哪个}或\emph{多少个}归纳假设。如果做了一个较弱的假设，却发现自己引用了那些未正式证明的``真理''，那将是非常遗憾的！相反，你不妨做出最强的假设，以备不时之需。尽管这可能显得有些小题大作（例如你实际上只需要 $P(k)$ 来推导 $P(k+1)$），但这并不重要，对吧？关键是要证明当前的命题，只要达到了这个目的，你就成功了。

随着你在数学领域的进步，你可能会更好地识别常规归纳和强归纳论证的区别。特别是，你可能会注意到什么时候确实需要强归纳法。通常，这种情况发生在处理递归定义的数列时，但也可能出现在许多其他地方。当你尝试解决一个问题时，看看你的命题实例之间存在什么样的依赖关系。如果你注意到一个实例依赖于多个之前的实例，你几乎百分百需要使用强归纳论证。

\subsection{习题}

\subsubsection*{温故知新}

以口头或书面的形式简要回答以下问题。这些问题全都基于你刚刚阅读的内容，所以如果忘记了具体的定义、概念或示例，可以回去重读相关部分。确保在继续学习之前能够自信地回答这些问题，这将有助于你的理解和记忆！

\begin{enumerate}[label=(\arabic*)]
    \item 强归纳法和普通归纳法的区别是什么？
    \item 你如何判断何时需要使用强归纳法？
    \item 为什么我们总是可以选择使用强归纳法，而不是在常规归纳法和强归纳法之间做选择？
    \item 在质因数分解的例子中，使用的归纳假设（IH）有什么特别之处？与我们在其他例子中证明递归定义的数列公式相比，有什么不同？
\end{enumerate}

\subsubsection*{小试牛刀}

尝试回答以下问题。这些题目要求你实际动笔写下答案，或（对朋友/同学）口头陈述答案。目的是帮助你练习使用新的概念、定义和符号。题目都比较简单，确保能够解决这些问题将对你大有帮助！

\begin{enumerate}[label=(\arabic*)]
    \item 定义数列
        \[x_1=2 \;\text{ 且 }\; x_2=3 \;\text{ 且 }\; \forall n \in \mathbb{N}-\{1,2\} \centerdot x_n=3x_{n-1}-2x_{n-2}\]
        证明
        \[\forall n \in \mathbb{N} \centerdot x_n = 2^{n-1} + 1\]
    \item 数列 $a_n$ 定义为 $a_0 = 0, a_1 = 1$ 且
        \[\forall n \in \mathbb{N}-\{1\} \centerdot a_n=5x_{n-1}-6x_{n-2}\]
        即 $\langle a_n \rangle = \langle 0, 1, 5, 19, 65, 211, \dots \rangle$。
        
        证明对于所有 $n \in \mathbb{N} \cup \{0\}, a_n = 3^n-2^n$。
    \item 设 $a_1 \in \mathbb{Z}$ 是任意且固定的。定义数列
        \[\forall n \in \mathbb{N} - \{1\} \centerdot a_n = \sum_{k=1}^{n-1}k^2a_k\]
        证明
        \[a_1 \text{ 为偶数} \implies \forall n \in \mathbb{N} \centerdot a_n \text{ 为偶数}\]
    \item 定义数列 $\langle t_n \rangle$
        \[t_1=t_2=2 \;\text{ 且 }\; \forall n \in \mathbb{N}-\{1,2\} \centerdot t_n=\frac{1}{2t_{n-2}}(t_{n-1}-4)(t_{n-1}-6)\]
        证明 $\forall n \in \mathbb{N} \centerdot t_n=2$。
    \item 你之前可能见过\textbf{三角不等式}；它说的是
        \[\forall x,y \in \mathbb{R} \centerdot |x+y| \le |x| + |y|\]
        （其中 $|x|$ 表示 $x$ 的绝对值）。证明该不等式不仅仅对 $2$ 个变量成立，而是对 $n$ 个变量都成立；也就是说，证明如果我们有实数 $x_i$ 组成的数列，即 $\forall i \in \mathbb{N} \centerdot x_i \in \mathbb{R}$，那么
        \[\forall i \in \mathbb{N} \centerdot \vert \sum_{i=1}^{n} x_i \vert \le \sum_{i=1}^{n} |x_i|\]
        (注意：要证明 $n = 2$ 的情况。而不能仅仅只是假设！)
    \item 回想一下 \ref{sec:section2.4.1} 节，我们曾讨论过如何用多米诺骨牌密铺 $2 \times n$ 的矩形棋盘。现在，我们来研究一个类似的问题，如何用条状三连块（即 $3 \times 1$ 的矩形块）密铺 $3 \times n$ 矩形棋盘。试着找出其中的归纳关系，并定义一个数列来表示密铺 $3 \times n$ 棋盘的方法数。

    （注意：不要尝试找到一个封闭形式或者证明它！这需要的技术超出了我们目前的讨论范围。如果你感兴趣，可以查找\textbf{递推关系}。如果愿意，可以尝试根据你读到的内容为这个问题找到一个封闭形式。你能通过归纳法证明它吗？）
\end{enumerate}