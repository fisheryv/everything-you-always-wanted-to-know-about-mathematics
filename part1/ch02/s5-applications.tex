% !TeX root = ../../book.tex
\section{应用}

\subsection{递归程序}\label{sec:section2.5.1}

数学归纳法背后的概念也大量应用于计算机科学中。回想一下我们当初是如何推导出 $\sum_{k=1}^{n}k^2$ 的公式的。一旦我们找到了用更小的立方和剩余项来表示立方数的方法，我们就会一遍又一遍地重复这个替代过程，直到我们到达``最简单''的情况，即我们在开始计算问题：$2^3=1+3+3+1$ 时第一次观察到的情况。递归编程利用了这一技术：为了解决``大''问题，确定问题如何依赖于``小''案例，并化简问题，直到达到一个简单的已知案例。

此类技术的一个经典示例是编写代码来计算\emph{阶乘} $n!$，它被定义为前 $n$ 个自然数的乘积：
\[n! = 1 \cdot 2 \cdot 3 \dots (n - 1) \cdot n\]
这是一个简单的定义，我们作为人类可以直观地理解，但告诉计算机如何执行该产品的方式并不完全相同。（尝试一下！怎么用计算机代码表达``继续执行，直到达到 $n$''？）事实上，对函数进行编程的一种更有效的方法，以及对数学归纳定义进行建模的方法，是让一个程序\emph{递归地调用自身}，直到达到``最简''情况。在阶乘种，这种情况就是 $1! = 1$。对于 $n$ 的任意其他值，我们可以简单地不断应用以下知识：
\[n! = (n - 1)! \cdot n\]
来计算 $n!$。下面的\emph{伪代码}描述了这一思想：

\begin{verbatim}
    factorial(n):
        if n = 1
            return 1
        else
            return n * factorial(n-1)
    end
\end{verbatim}

我们知道 $1! = 1$，因此如果要求程序计算该值，则会立即返回正确的结果。对于任意大于 $1$ 的 $n$ 值，程序都会引用\emph{自身}，并说：``为我计算 $(n-1)!$，然后我在后面乘上 $n$ 就得到答案了。''为了计算 $(n-1)!$，程序会再次询问输入是否为 $1$；如果不为 $1$，则会继续调用自身并说：``为我计算 $(n-2)!$，然后我在后面乘上 $(n-1)$ 。'' 这个过程一直持续到程序返回 $1! = 1$。从那之后，程序就知道如何求出 $2! = 1 \times 2$，然后是 $3! = 2! \times 3$，依此类推，直到 $n! = (n - 1)! \times n$。

递归编程的另一个经典例子是\emph{斐波那契数}。可能你之前在数学课上见过这个数列。（事实上，我们在上一节多米诺骨牌密铺中提到过该数列！）你可能还听说过斐波那契数列以一些有趣和奇怪的方式出现在自然界中。（该数列最早是由比萨的意大利数学家莱昂纳多·斐波那契(Leonardo Fibonacci)在研究兔子种群增长时``发现''的。）斐波那契数列的前两项均为 $1$，数列中的任意数字都被定义为前两个数字之和。也就是说，如果我们用 $F(n)$ 表示第 $n$ 个斐波那契数，那么
\[F(1) = 1 \text{ 且 }F(2) = 1, \text{ 对于任意 } n \ge 3, F(n) = F(n - 1) + F(n - 2)\]
那么，$F(5)$ 等于多少？$F(100)$ 呢？$F(10000)$ 呢？这可以通过递归程序很容易地处理。思路是一样的：如果程序遇到``简单情况''之一，即 $F(1)$ 或 $F(2)$，则立即返回正确值 $1$。否则，将调用自身来计算前两个数字，然后将它们相加。阅读下面的伪代码并思考它是如何工作的。如果我们使用这个程序来计算 $F(10)$ 会发生什么？怎样才能得出答案呢？

\begin{verbatim}
    Fibonacci(n):
        if n = 1 or n = 2
            return 1
        else
            return Fibonacci(n-1) + Fibonacci(n-2)
    end
\end{verbatim}

上面程序与 \verb|factorial| 程序的思路相同（让程序调用自身来计算函数``较小''情况的值，直到达到已知值），但这里有一些更深层次的内容。但这里有一些更深层次的内容。如果我们将 $n = 10$ 输入到程序中，它会识别出还不知道应该输出什么值，于是会调用自身来计算 \verb|Fibonacci(9)| 和 \verb|Fibonacci(8)|。对程序的每次调用，都会再次识别出该值未知。因此，会再次调用自身来计算 \verb|Fibonacci(8)| 和 \verb|Fibonacci(7)|，以及 \verb|Fibonacci(7)| 和 \verb|Fibonacci(6)|。没错，程序使用相同的输入值多次调用自身。为了计算 $F(9)$，我们需要知道 $F(8)$ 和 $F(7)$，但同时，为了计算 $F(8)$，我们还需要知道 $F(7) $ 和 $F(6)$。这样，我们最终多次调用程序 \verb|Fibonacci|。

尝试比较 \verb|Fibonacci| 程序和 \verb|factorial| 程序，特别是关于我们在本章中研究的归纳过程。他们使用类似的思路吗？ 它们与我们介绍数学归纳法时用到的``多米诺骨牌''类比有何关系？将多米诺骨牌 $n$ 上的``事实''视为对 $n!$ 的正确计算或 $F(n)$。这个类比在每种情况下如何发挥作用？所有多米诺骨牌都会倒下吗？在你继续阅读时，请记住这些问题。所有这些想法背后都有一些非常强大的数学基础。

\clearpage

\subsection{汉诺塔}

我们休息一下，玩个游戏吧。其实不完全是休息，因为从某种意义上来说，这是一个\emph{归纳}游戏，所以是完全相关的。但好歹是个游戏！\emph{汉诺塔}是一个非常受欢迎的智力游戏，部分原因在于它的规则和设备都很简单。不过解决这个问题却一点也不简单！

想象一下，我们有三个垂直的杆和三个不同尺寸（\textcolor{blue}{蓝色}、\textcolor{olivegreen}{绿色}和\textcolor{red}{红色}）的圆盘，彼此叠放在一起，如下所示：

\begin{center}
    \begin{tikzpicture}[line width=4mm,line cap=round,xscale=3,brown!30]
        \def\sequence{3/1,2/1,1/1}
        % init colors
        \foreach[count=\j] \c in {red,olivegreen,blue}
            \gset col[\j]={\c};
        \edef\numdisks{\j}
        % init positions and draw support
        \foreach \j in {1,2,3}{
            \gset pos[\j]=0
            \draw (\j,-.4) -- +(0,3);
        }
        \draw (.5,-.4) -- +(3,0);

        % draw
        \foreach[count=\k] \i/\j in \sequence{
            \edef\delta{\i*0.4/3}
            \draw[draw={\get col[\i]}](\j-\delta,\get pos[\j]) -- (\j+\delta,\get pos[\j]);
            \ginc pos[\j]+={.4}
        }
    \end{tikzpicture}
\end{center}
目标是通过遵循以下规则将所有三个圆盘移动到另一根杆上（无论是中间的还是右边的，都没关系）：

\begin{enumerate}
    \item 每次移动只能将一根杆子顶部的一个（且\emph{仅有}一个）圆盘，移动到另一根杆子的顶部，
    \item 任何圆盘不能放置在比它小的圆盘之上。
\end{enumerate}
就这些！两条简单的规则，但却是一个很难的游戏。尝试用一些硬币或扑克牌或任何你手边的东西来模拟这个游戏。（你甚至可以在一些游戏商店购买汉诺塔套装。）你能解决这个问题吗？ 你花了多少步？你的解决方案是``最好''的吗？为什么是或者为什么不是呢？

我们提到过这是一个归纳游戏，所以让我们探讨一下这个想法。我们想要解决这个难题需要多少步（其中一步表示一个圆盘从一根杆移动到另一根杆），更具体地说，确定解决这个难题所需的\emph{最小可能步数}。对于三个圆盘的问题，如果我们愿意的话，完全可以不断地在两根杆之间来回移动最小圆盘并产生 $100$ 次移动，然后再解决它，但这肯定不是最好的方法，对吗？假设我们找到了一种在一定步数内解决问题的方法；我们如何证明我们使用的步数是最小可能步数？

为了解决这个问题，我们想\emph{递归地}分解解题方法。在此过程中，我们实际上要回答一个更普遍的问题：解决 $3$ 根杆上 $n$ 个圆盘的汉诺塔问题需要的最小移动步数是多少？我们仅用 $3$ 个圆盘提出了问题，是为了便于为你提供一个具体的版本供你思考和使用，但我们可以通过深入思考来回答这个更普遍的问题。为了确保我们理解一致，我们将向你展示如何解决具有 $3$ 个圆盘的问题：

\begin{center}
    \begin{tikzpicture}[line width=2.6mm,line cap=round,xscale=1.5,yscale=0.5,brown!30]
        \def\sequencelist{{3/1,2/1,1/1}, {3/1,2/1,1/3}, {3/1,2/2,1/3}, {3/1,2/2,1/2}, {3/3,2/2,1/2}, {3/3,2/2,1/1}, {3/3,2/3,1/1}, {3/3,2/3,1/3}}
        % init colors
        \foreach[count=\j] \c in {red,olivegreen,blue}
            \gset col[\j]={\c};
        \edef\numdisks{\j}
        \foreach[count=\n] \sequence in \sequencelist {
            % init positions and draw support
            \foreach \j in {1,2,3}{
                \gset pos[\j]=0
                \draw (\j,-0.4-5*\n) -- +(0, 3);
            }
            \draw (0.5,-0.52-5*\n) -- +(3,0);
            % draw
            \foreach[count=\k] \i/\j in \sequence{
                \edef\delta{\i*0.4/3}
                \draw[draw={\get col[\i]}](\j-\delta,\get pos[\j]-5*\n) -- (\j+\delta,\get pos[\j]-5*\n);
                \ginc pos[\j]+={0.52}
            }
        }
        \node[black,left] at (0,-5.52){开始};
        \foreach \m in {1, ..., 7} {
            \node[black,left] at (0,-5.52-5*\m){第 \m 步};
        }   
    \end{tikzpicture}
\end{center}

请注意，最大的圆盘对于大多数解决方案来说基本上是``无关''的。由于我们可以在其上面放置任何其他圆盘，因此我们需要做的就是通过将其他圆盘移动到不同的杆上来``露出''该圆盘，将最大的圆盘移动到唯一的空杆上，然后再将其他圆盘移到大圆盘上。本质上，我们执行相同的过程（将两个较小的圆盘从一根杆移动到另一根杆）两次，在两次之间，我们将大圆盘从一根杆移动到另一根杆。如果最大的圆盘根本不存在，那么我们实际做的就是 $2$ 个圆盘的题目，只是做了两次！（仔细思考这一点，确保你理解了上面这段话。假装大的\textcolor{blue}{蓝色}圆盘不存在，操作一遍上图中步骤。）

这表明解决 $3$ 盘问题的方法涉及解决 $2$ 盘问题的两次迭代，中间有一次额外的移动（移动最大的圆盘）。一般来说，这表明了解决该问题的\emph{递归}过程。为了最优地解决 $n$ 盘问题，我们只需遵循解决 $(n - 1)$ 盘问题的最优过程，用一步移动最大的第 $n$ 个圆盘，然后再次求解 $(n - 1)$ 盘问题。

现在我们对如何最优地解决这个问题有了一些了解，让我们确定该过程需要几步。认识到解决这个问题需要使用\emph{递归}算法，我们意识到\emph{证明}有关最佳解决方案的任何内容都需要\emph{归纳法}。因此，我们需要为我们的多米诺骨牌线确定一个``起点''，它应该对应于问题的``最小''或``最简单''版本。对于汉诺塔问题来说，最简问题就是 $1$ 个圆盘问题。当然，这几乎不是一个``问题''，因为我们可以一步解决它，只需将唯一的圆盘从一根杆移动到另一根杆即可。如果我们令 $M(n)$ 表示解决 $n$ 盘问题所需的最少移动次数，那么我们就确定了 $M(1) = 1$。为了确定 $M(2)$，我们可以使用上面的观察结果并得到
\[\underbrace{M(2)}_{2 \text{盘问题}}= \underbrace{M(1)}_{1 \text{盘问题}}+ \underbrace{1}_{\text{移动最大盘}}+ \underbrace{M(1)}_{1 \text{盘问题}}= 1 + 1 + 1 = 3\]
接下来一定是
\[M(3) = M(2) + 1 + M(2) = 3 + 1 + 3 = 7\]
和
\[M(4) = M(3) + 1 + M(3) = 7 + 1 + 7 = 15\]
以此类推。你注意到其中的规律了吗？这些数字中的每一个都比 $2$ 的幂小 $1$，具体来说，我们注意到对于迄今为止我们所考察的每种情况，$M(n) = 2^n - 1$。需要指出的是，观察到这种规律并不等于证明了这种规律；因为它仅仅适用于前 $4$ 种情况，并不意味着这种规律会一直持续下去，而这正是归纳证明所要解决的问题。此外，认识到这种规律并``观察''到 $M(n) = 2^n - 1$ 本身就是一件了不起的事情。我们碰巧知道答案，并且可以直接找出公式。你可以尝试自己``解决''以下关系
\[M(n) = 2M(n - 1) + 1 \text{ 且 } M(1) = 1\]
看看能否推导出公式 $M(n) = 2^n -1$。这种公式比上面的关系式更好的原因在于，$M(n)$ 仅取决于 $n$，而\emph{不再}取决于之前的项（例如 $M(n-1)$）。这种关系和其他类似关系被称为\emph{递归关系}，一般来说，它们可能很难解决！

我们知道如何解决这个问题，并得出 $M(n) = 2^n - 1$。不过，相关的验证工作就留给你独立完成。你可以通过检查上面等式中的一些值来做到这一点，但我们都知道这并不构成\emph{证明}。尝试通过归纳步骤来实际证明这一点！我们已经完成了大部分工作，但还需你仔细、清晰地将一切串联在一起。请记住，你应该确定每张多米诺骨牌上的``事实''是什么，确保多米诺骨牌 $1$ 会倒下，然后对多米诺骨牌 $n$ 倒下会引起多米诺骨牌 $(n+1)$ 倒下进行一般论证。试着写出这个证明。这些细节对你来说有意义吗？向朋友展示你的证明，看看他们是否理解。你还需要告诉他们其他事情或指导他们完成证明阅读？考虑解释你的方法和步骤的最佳方式，以便书面版本就足够了，而不必添加任何口头解释。思考\emph{解释}你的方法和步骤的最佳方式，确保书面版本足够清晰准确，而不必添加任何口头解释。 

\subsection{习题}

\subsubsection*{温故知新}

以口头或书面的形式简要回答以下问题。这些问题全都基于你刚刚阅读的内容，所以如果忘记了具体的定义、概念或示例，可以回去重读相关部分。确保在继续学习之前能够自信地回答这些问题，这将有助于你的理解和记忆！

\begin{enumerate}[label=(\arabic*)]
    \item 递归程序如何归纳？
    \item 汉诺塔的归纳结构是什么？在解决 $3$ 盘问题时，我们在哪里解决了 $2$ 盘问题？
\end{enumerate}

\subsubsection*{小试牛刀}

尝试回答以下问题。这些题目要求你实际动笔写下答案，或（对朋友/同学）口头陈述答案。目的是帮助你练习使用新的概念、定义和符号。题目都比较简单，确保能够解决这些问题将对你大有帮助！

\begin{enumerate}[label=(\arabic*)]
    \item 按照伪代码 \verb|factorial| 的步骤计算 $5!$。
    \item 按照伪代码 \verb|Fibonacci| 的步骤计算 $F(5)$。
    \item 解决 $4$ 盘汉诺塔问题。确保你能以\emph{最优}步数 $2^4 - 1 = 15$ 步完成。
\end{enumerate}