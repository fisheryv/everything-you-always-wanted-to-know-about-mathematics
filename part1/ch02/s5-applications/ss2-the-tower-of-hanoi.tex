% !TeX root = ../../../book.tex
\subsection{汉诺塔}

我们休息一下，玩个游戏吧。其实不完全是休息，因为从某种意义上来说，这是一个\emph{归纳}游戏，所以是完全相关的。但好歹是个游戏！\emph{汉诺塔}是一个非常受欢迎的智力游戏，部分原因在于它的规则和设备都很简单。不过解决这个问题却一点也不简单！

想象一下，我们有三个垂直的杆和三个不同尺寸（\textcolor{blue}{蓝色}、\textcolor{olivegreen}{绿色}和\textcolor{red}{红色}）的圆盘，彼此叠放在一起，如下所示：

\begin{center}
    \begin{tikzpicture}[line width=4mm,line cap=round,xscale=3,brown!30]
        \def\sequence{3/1,2/1,1/1}
        % init colors
        \foreach[count=\j] \c in {red,olivegreen,blue}
            \gset col[\j]={\c};
        \edef\numdisks{\j}
        % init positions and draw support
        \foreach \j in {1,2,3}{
            \gset pos[\j]=0
            \draw (\j,-.4) -- +(0,3);
        }
        \draw (.5,-.4) -- +(3,0);

        % draw
        \foreach[count=\k] \i/\j in \sequence{
            \edef\delta{\i*0.4/3}
            \draw[draw={\get col[\i]}](\j-\delta,\get pos[\j]) -- (\j+\delta,\get pos[\j]);
            \ginc pos[\j]+={.4}
        }
    \end{tikzpicture}
\end{center}
目标是通过遵循以下规则将所有三个圆盘移动到另一根杆上（无论是中间的还是右边的，都没关系）：

\begin{enumerate}
    \item 每次移动只能将一根杆子顶部的一个（且\emph{仅有}一个）圆盘，移动到另一根杆子的顶部，
    \item 任何圆盘不能放置在比它小的圆盘之上。
\end{enumerate}
就这些！两条简单的规则，但却是一个很难的游戏。尝试用一些硬币或扑克牌或任何你手边的东西来模拟这个游戏。（你甚至可以在一些游戏商店购买汉诺塔套装。）你能解决这个问题吗？ 你花了多少步？你的解决方案是``最好''的吗？为什么是或者为什么不是呢？

我们提到过这是一个归纳游戏，所以让我们探讨一下这个想法。我们想要解决这个难题需要多少步（其中一步表示一个圆盘从一根杆移动到另一根杆），更具体地说，确定解决这个难题所需的\emph{最小可能步数}。对于三个圆盘的问题，如果我们愿意的话，完全可以不断地在两根杆之间来回移动最小圆盘并产生 $100$ 次移动，然后再解决它，但这肯定不是最好的方法，对吗？假设我们找到了一种在一定步数内解决问题的方法；我们如何证明我们使用的步数是最小可能步数？

为了解决这个问题，我们想\emph{递归地}分解解题方法。在此过程中，我们实际上要回答一个更普遍的问题：解决 $3$ 根杆上 $n$ 个圆盘的汉诺塔问题需要的最小移动步数是多少？我们仅用 $3$ 个圆盘提出了问题，是为了便于为你提供一个具体的版本供你思考和使用，但我们可以通过深入思考来回答这个更普遍的问题。为了确保我们理解一致，我们将向你展示如何解决具有 $3$ 个圆盘的问题：

\begin{center}
    \begin{tikzpicture}[line width=2.6mm,line cap=round,xscale=1.5,yscale=0.5,brown!30]
        \def\sequencelist{{3/1,2/1,1/1}, {3/1,2/1,1/3}, {3/1,2/2,1/3}, {3/1,2/2,1/2}, {3/3,2/2,1/2}, {3/3,2/2,1/1}, {3/3,2/3,1/1}, {3/3,2/3,1/3}}
        % init colors
        \foreach[count=\j] \c in {red,olivegreen,blue}
            \gset col[\j]={\c};
        \edef\numdisks{\j}
        \foreach[count=\n] \sequence in \sequencelist {
            % init positions and draw support
            \foreach \j in {1,2,3}{
                \gset pos[\j]=0
                \draw (\j,-0.4-5*\n) -- +(0, 3);
            }
            \draw (0.5,-0.52-5*\n) -- +(3,0);
            % draw
            \foreach[count=\k] \i/\j in \sequence{
                \edef\delta{\i*0.4/3}
                \draw[draw={\get col[\i]}](\j-\delta,\get pos[\j]-5*\n) -- (\j+\delta,\get pos[\j]-5*\n);
                \ginc pos[\j]+={0.52}
            }
        }
        \node[black,left] at (0,-5.52){开始};
        \foreach \m in {1, ..., 7} {
            \node[black,left] at (0,-5.52-5*\m){第 \m 步};
        }   
    \end{tikzpicture}
\end{center}

请注意，最大的圆盘对于大多数解决方案来说基本上是``无关''的。由于我们可以在其上面放置任何其他圆盘，因此我们需要做的就是通过将其他圆盘移动到不同的杆上来``露出''该圆盘，将最大的圆盘移动到唯一的空杆上，然后再将其他圆盘移到大圆盘上。本质上，我们执行相同的过程（将两个较小的圆盘从一根杆移动到另一根杆）两次，在两次之间，我们将大圆盘从一根杆移动到另一根杆。如果最大的圆盘根本不存在，那么我们实际做的就是 $2$ 个圆盘的题目，只是做了两次！（仔细思考这一点，确保你理解了上面这段话。假装大的\textcolor{blue}{蓝色}圆盘不存在，操作一遍上图中步骤。）

这表明解决 $3$ 盘问题的方法涉及解决 $2$ 盘问题的两次迭代，中间有一次额外的移动（移动最大的圆盘）。一般来说，这表明了解决该问题的\emph{递归}过程。为了最优地解决 $n$ 盘问题，我们只需遵循解决 $(n - 1)$ 盘问题的最优过程，用一步移动最大的第 $n$ 个圆盘，然后再次求解 $(n - 1)$ 盘问题。

现在我们对如何最优地解决这个问题有了一些了解，让我们确定该过程需要几步。认识到解决这个问题需要使用\emph{递归}算法，我们意识到\emph{证明}有关最佳解决方案的任何内容都需要\emph{归纳法}。因此，我们需要为我们的多米诺骨牌线确定一个``起点''，它应该对应于问题的``最小''或``最简单''版本。对于汉诺塔问题来说，最简问题就是 $1$ 个圆盘问题。当然，这几乎不是一个``问题''，因为我们可以一步解决它，只需将唯一的圆盘从一根杆移动到另一根杆即可。如果我们令 $M(n)$ 表示解决 $n$ 盘问题所需的最少移动次数，那么我们就确定了 $M(1) = 1$。为了确定 $M(2)$，我们可以使用上面的观察结果并得到
\[\underbrace{M(2)}_{2 \text{盘问题}}= \underbrace{M(1)}_{1 \text{盘问题}}+ \underbrace{1}_{\text{移动最大盘}}+ \underbrace{M(1)}_{1 \text{盘问题}}= 1 + 1 + 1 = 3\]
接下来一定是
\[M(3) = M(2) + 1 + M(2) = 3 + 1 + 3 = 7\]
和
\[M(4) = M(3) + 1 + M(3) = 7 + 1 + 7 = 15\]
以此类推。你注意到其中的规律了吗？这些数字中的每一个都比 $2$ 的幂小 $1$，具体来说，我们注意到对于迄今为止我们所考察的每种情况，$M(n) = 2^n - 1$。需要指出的是，观察到这种规律并不等于证明了这种规律；因为它仅仅适用于前 $4$ 种情况，并不意味着这种规律会一直持续下去，而这正是归纳证明所要解决的问题。此外，认识到这种规律并``观察''到 $M(n) = 2^n - 1$ 本身就是一件了不起的事情。我们碰巧知道答案，并且可以直接找出公式。你可以尝试自己``解决''以下关系
\[M(n) = 2M(n - 1) + 1 \text{ 且 } M(1) = 1\]
看看能否推导出公式 $M(n) = 2^n -1$。这种公式比上面的关系式更好的原因在于，$M(n)$ 仅取决于 $n$，而\emph{不再}取决于之前的项（例如 $M(n-1)$）。这种关系和其他类似关系被称为\emph{递归关系}，一般来说，它们可能很难解决！

我们知道如何解决这个问题，并得出 $M(n) = 2^n - 1$。不过，相关的验证工作就留给你独立完成。你可以通过检查上面等式中的一些值来做到这一点，但我们都知道这并不构成\emph{证明}。尝试通过归纳步骤来实际证明这一点！我们已经完成了大部分工作，但还需你仔细、清晰地将一切串联在一起。请记住，你应该确定每张多米诺骨牌上的``事实''是什么，确保多米诺骨牌 $1$ 会倒下，然后对多米诺骨牌 $n$ 倒下会引起多米诺骨牌 $(n+1)$ 倒下进行一般论证。试着写出这个证明。这些细节对你来说有意义吗？向朋友展示你的证明，看看他们是否理解。你还需要告诉他们其他事情或指导他们完成证明阅读？考虑解释你的方法和步骤的最佳方式，以便书面版本就足够了，而不必添加任何口头解释。思考\emph{解释}你的方法和步骤的最佳方式，确保书面版本足够清晰准确，而不必添加任何口头解释。 
