% !TeX root = ../../../book.tex

\subsection{函数相等}

有时，两个函数虽然由不同的规则或公式定义，但实际上表示了相同的对应关系！此时，这两个函数\textbf{相等}。我们将先从函数符号的角度描述这一情形，再通过对应关系和集合符号加以证明。

两个函数\emph{相等}的条件是什么？首先，其定义域必须相同。若定义域不同，则其中一个定义域包含另一个定义域中不存在的元素。（例如，一个函数在某元素上有定义而另一个函数无定义，二者显然不等）。设集合 $A$ 和 $B$，以及函数 $f : A \to B$ 和 $g : A \to B$。$f$ 与 $g$ 相等需满足何种条件？函数的核心特征在于：对任意输入 $x \in A$，$f$ 和 $g$ 均有\emph{唯一}输出 $f(x)$ 和 $g(x)$。若 $f$ 与 $g$ 为同一函数，则必有 $f(x) = g(x)$！由此可得如下定理。

\begin{theorem}
   设 $A, B$ 为集合。并设 $f : A \to B$ 和 $g : A \to B$ 为函数。若
   \[\forall x \in A \centerdot f(x) = g(x)\]
   则称 $f$ 与 $g$ 相等，记作 $f = g$。
\end{theorem}

这确实是一个\emph{定理}。该思想虽直观，却并未在函数的\emph{定义}中明示，因此需要证明。为此，考察 $f$ 和 $g$ 的所有有序对。通过证明这些有序对相同，可以在集合意义上得出 $f = g$。以下采用\emph{双向包含}论证。

\begin{proof}
   设 $A, B$ 为集合，$f : A \to B$ 和 $g : A \to B$ 为函数，且满足 $\forall x \in A \centerdot f(x) = g(x)$。
   \begin{itemize}
      \item 首先，证明 $f \subseteq g$。\\
            给定 $(a,b) \in f$。因为 $f$ 为函数，这意味着 $f(a) = b$。由题设 $f(a) = g(a)$ 可得 $g(a) = b$。因此 $(a,b) \in g$。这表明
            \[(a, b) \in f \implies (a, b) \in g\]
            即 $f \subseteq g$。
      \item 接着，证明 $g \subseteq f$。\\
            给定 $(c,d) \in g$。因为 $g$ 为函数，这意味着 $g(c) = d$。由题设 $f(c) = g(c)$ 可得 $f(c) = d$。因此 $(c,d) \in f$。这表明
            \[(c, d) \in g \implies (c, d) \in f\]
            即 $g \subseteq f$。
   \end{itemize}
    
   综上，由 $f \subseteq g$ 和 $g \subseteq f$，可得 $f = g$。
\end{proof}

这为我们提供了一种简便的方法来证明两个函数相等，而不需要深入探讨它们的底层关系或集合结构。我们只需要证明两个函数对于定义域中的每一个元素，其输出是相同的。接下来，我们通过几个例子来说明这一点。\\

\begin{example}
    设 $A = \{-1, 0, 1\}$。定义函数 $f_1 : A \to \mathbb{Z}$ 和 $f_2 : A \to \mathbb{Z}$ 为
    \[\forall x \in A \centerdot \big(f_1(x) = x\big) \land \big(f_2(x) = x^3\big)\]
    证明 $f_1 = f_2$。由于定义域只包含三个元素，我们可以逐一检验输出。
    \begin{align*}
        f_1(-1) = -1 &= (-1)^3 = f_2(-1)\\
        f_1(0) = 0 &= 0^3 = f_2(0)\\
        f_1(1) = 1 &= 1^3 = f_2(1)
    \end{align*}
    可见，对于每个合法输入（即 $\forall x \in A$）函数 $f_1$ 和 $f_2$ 均有相同的输出（即 $f_1(x) = f_2(x)$）。因此 $f_1 = f_2$。
\end{example}

\begin{example}
    设 $B = \{1, 2, 3\}$。定义函数 $g_1 : B \to \mathbb{Z}$ 和 $g_2 : B \to \mathbb{Z}$ 为
    \[\forall n \in B \centerdot \big(g_1(n) = n^3-n^2-6\big) \land \big(g_2(n) = 5n^2-11n\big)\]
    证明 $g_1 = g_2$。定义域还是只有三个元素，所以我们可以直接验证所有输出相等。
    \begin{align*}
        g_1(1) &= 1^3 - 1^2 - 6 = 1 - 1 - 6 = -6 \\
        g_2(1) &= 5 \cdot 1^2 - 11 \cdot 1 = 5 - 11 = -6 
   \end{align*}
   \begin{align*}
        g_1(2) &= 2^3 - 2^2 - 6 = 8 - 4 - 6 = -2 \\
        g_2(2) &= 5 \cdot 2^2 - 11 \cdot 2 = 20 - 22 = -2
   \end{align*}
   \begin{align*}
        g_1(3) &= 3^3 - 3^2 - 6 = 27 - 9 - 6 = 12 \\
        g_2(3) &= 5 \cdot 3^2 - 11 \cdot 3 = 45 - 33 = 12
    \end{align*}

    可见 $\forall n \in B \centerdot g_1(n) = g_2(n)$，因此 $g_1 = g_2$。
\end{example}

以上两个例子的定义域较小，可以逐一检查每个元素。然而，并非所有情况都如此简单。有时需要考虑定义域内任意元素（因为待证性质以``$\forall$''量词开头），并据此展开分析。实际上，针对此类情形存在一种巧妙的方法，接下来我们将演示其具体实现。

给定 $n \in B$。由于 $g_1(n)$ 和 $g_2(n)$ 都属于 $\mathbb{Z}$，考虑它们的差
\begin{align*}
    g_1(n) - g_2(n) &= (n^3 - n^2 - 6) - (5n^2 - 11n) \\
    &= n^3 - 6n^2 - 11n - 6 \\
    &= (n - 1)(n - 2)(n - 3)
\end{align*}

（注意：可以通过简单地展开这三项的乘积来验证最后的等式。）

由于 $n \in B$，因此 $n$ 只可能是 $1,2,3$。在每种情况下，$(n - 1), (n - 2), (n - 3)$ 其中一项必定为零。因此
\[g_1(n) - g_2(n) = (n - 1)(n - 2)(n - 3) = 0\]
由此可得 $g_1(n) = g_2(n)$。此式对任意 $n \in B$ 都成立，故得出结论 $g_1 = g_2$。

需要指出的是，此法比``逐项验证''更复杂。我们是怎么知道要做差的呢？我们又是如何知道它会以这样的形式因式分解的呢？这正是数学的魅力所在！或许是通过思考如何解决更一般的问题从而得到某种巧妙的方法，因为在此情形下，定义域太大，根本无法逐一验证。或许是识别出 $B = \{1, 2, 3\}$ 隐含的因式分解结构。只要仔细思考，便可领悟此例是如何巧妙构造出来的！$\smiley{}$

让我们来看一个更复杂的函数相等问题。下例涉及若干对你来说可能陌生的概念，后续也不会深入讨论，然而鉴于这个问题的趣味性与启发性，所以将其呈现在这里。\\

\begin{example}
    本例中，我们将定义两个函数，并说明它们为何相等。设每个函数的定义域和值域为 $\mathbb{R}^2$（实平面）。接下来，通过几何方式（即视觉上）定义两个函数 $F_1$ 和 $F_2$。定义 $F_1$ 输入平面上的一个点 $p$，并输出将 $p$ 绕原点逆时针旋转 $90 \degree$ 后再根据原点镜像得到的点。定义 $F_2$ 输入点 $p$，并输出将 $p$ 顺时针旋转 $90 \degree$ 后得到的点。为了更好地理解这两个函数的含义，请看下页中 $F_1$ 和 $F_2$ 的示意图。
    
    我们声称在函数意义上 $F_1 = F_2$。通过尝试几个例子，我们发现这可能是成立的，因为我们无法找到反例，甚至你可能已经``看出''为什么它成立。但这些都不是严格的证明，而只是一种直观的理解方法。为了严格证明这个事实，我们需要使用一些超出本课程范围的数学工具和方法。因此，我们只会概述证明过程，并将技术细节留给感兴趣的读者探索。

    \begin{multicols}{2}
        \begin{center}
            {\begin{tikzpicture}
                \draw[latex-latex] (-3,0) -- (3,0); 
                \draw[latex-latex] (0,-3) -- (0,3); 
                \draw (0,0) -- (1.5,1.5);
                \node at (1.5, 1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, 1.5)}] node[right] {$p$};
                \draw (0,0) -- (-1.5,1.5);
                \node at (-1.5, 1.5)[circle,fill,inner sep=2pt]{};
                \draw[rotate=45] (0,0) rectangle (0.3,0.3);
                \draw (0,0) -- (1.5,-1.5);
                \node at (1.5, -1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, -1.7)}] node[right] {$F_1(p)$};
                \draw[dashed,-latex] (1.5, 1.5) .. controls (0.5, 2.5) and (-0.5, 2.5) .. (-1.4, 1.6);
                \draw[shift={(-0.5, 2.5)}] node[left] {\small 旋转 $90 \degree$};
                \draw[dashed,-latex] (-1.5, 1.5) .. controls (-2, 0) and (-1.5, -2) .. (1.4, -1.6);
                \draw[shift={(-1.0, -0.3)}] node[right] {\small 相对};
                \draw[shift={(-1.0, -0.7)}] node[right] {\small 原点};
                \draw[shift={(-1.0, -1.1)}] node[right] {\small 镜像};
            \end{tikzpicture}}
        \end{center}

        \begin{center}
            {\begin{tikzpicture}
                \draw[latex-latex] (-3,0) -- (3,0); 
                \draw[latex-latex] (0,-3) -- (0,3); 
                \draw (0,0) -- (1.5,1.5);
                \node at (1.5, 1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, 1.5)}] node[right] {$p$};
                \draw (0,0) -- (1.5,-1.5);
                \node at (1.5, -1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, -1.7)}] node[right] {$F_2(p)$};
                \draw[rotate=-45] (0,0) rectangle (0.3,0.3);
                \draw[dashed,-latex] (1.5, 1.5) .. controls (2.5, 0.5) and (2.5, -0.5) .. (1.6, -1.4);
                \draw[shift={(0.5, 0.3)}] node[right] {\small 旋转 $90 \degree$};
            \end{tikzpicture}}
        \end{center}
    \end{multicols}

    主要思想是：我们可以用\emph{向量}表示平面上的点，用\emph{矩阵}表示函数，并通过矩阵乘法描述函数对点的作用。如果你对矩阵或向量不太熟悉，不用担心；你可以跳过这个例子，不会错过关键内容！不过，如果你想进一步了解，我们可以这样解释：矩阵是实数数组，而向量是单列矩阵。例如，实平面上的点 $(1, 1)$ 可表示为向量 $\begin{bmatrix}
        1 \\
        1
     \end{bmatrix}$。向量的\emph{旋转}可以通过\emph{旋转矩阵}实现（你可能在中级物理课程，如电磁学或力学中学过）。例如，逆时针旋转 $90 \degree$ 的矩阵表示为：
     \[\begin{bmatrix}
        0 & -1 \\
        1 & 0
     \end{bmatrix}\]
     将点 $(a, b)$ 逆时针旋转 $90 \degree$，等价于将对应向量与此矩阵相乘，遵循标准矩阵乘法规则（即行与列对应元素相乘并相加）。例如，旋转点 $(1, 1)$：
     \[\begin{bmatrix}
        0 & -1 \\
        1 & 0
     \end{bmatrix}\begin{bmatrix}
        1 \\
        1
     \end{bmatrix} = \begin{bmatrix}
        0+(-1) \\
        1+0
     \end{bmatrix}=\begin{bmatrix}
        -1 \\
        1
     \end{bmatrix}\]
     结果正如预期！请参阅上方图片了解旋转的实际效果。

     类似地，顺时针旋转 $90 \degree$ 的矩阵可以表示为：
     \[\begin{bmatrix}
        0 & 1 \\
        -1 & 0
     \end{bmatrix}\]

     （注意这些项的相似性，这是有原因的，建议通过搜索引擎探索细节。）

   以原点为中心的镜像也可用矩阵乘法表示，但更简单的理解是：将两个坐标取相反数。例如，镜像 $(-1, 1)$ 得到 $(1, -1)$。

   这使我们能完整描述 $F_1$ 和 $F_2$ 的动作。由于 $F_1$ 表示``逆时针旋转 $90 \degree$ 后取反坐标''，因此可以写作：
    \[F_1\Bigg(\begin{bmatrix}
        a \\
        b
     \end{bmatrix}\Bigg) = -\begin{bmatrix}
        0 & -1 \\
        1 & 0
     \end{bmatrix}\begin{bmatrix}
        a \\
        b
     \end{bmatrix}=\begin{bmatrix}
        b \\
        -a
     \end{bmatrix}\]
     （负号用于取反操作）。由于 $F_2$ 表示``顺时针旋转 $90 \degree$''，可以写作：
     \[F_2\Bigg(\begin{bmatrix}
        a \\
        b
     \end{bmatrix}\Bigg) = \begin{bmatrix}
        0 & 1 \\
        -1 & 0
     \end{bmatrix}\begin{bmatrix}
        a \\
        b
     \end{bmatrix}=\begin{bmatrix}
        b \\
        -a
     \end{bmatrix}\]
     根据矩阵与向量的乘法规则，我们可以轻易看出，对于任意 $a$ 和 $b$，这两个表达式相等。因此，假如你熟悉旋转矩阵，这就证明了 $F_1 = F_2$！
\end{example}