% !TeX root = ../../../book.tex

\subsection{函数相等}

有时候，两种函数虽然由不同的规则或公式定义，但实际上它们对应相同的底层关系！在这种情况下，这两个函数是\textbf{相等的}。我们将先用函数符号来描述这种情况，然后再用底层关系和集合符号来证明这一点。

两个函数如何才能\emph{相等}呢？首先，它们的定义域必须相同。如果定义域不同，那么其中一个定义域中包含了另一个定义域中没有的元素，这就会出现问题。（想象一下：一个函数在某个元素上有定义，而另一个函数在相同元素上没有定义，这样它们就不可能相等）。假设我们有两个集合 $A$ 和 $B$，以及两个函数 $f : A \to B$ 和 $g : A \to B$。为了使 $f$ 和 $g$ 相等，我们需要满足什么条件呢？函数的定义特征是，对于任意输入 $x \in A$，函数 $f$ 和 $g$ 都有\emph{唯一}的输出 $f(x)$ 和 $g(x)$。如果 $f$ 和 $g$ 是相同的函数，那么我们必有 $f(x) = g(x)$！这让我们可以陈述以下定理。

\begin{theorem}
    设 $A, B$ 为集合。并设 $f : A \to B$ 和 $g : A \to B$ 为函数。假设
    \[\forall x \in A \centerdot f(x) = g(x)\]
    则我们称 $f$ 和 $g$ 是相等的函数，记作 $f = g$。
\end{theorem}

这确实是一个\emph{定理}。这个想法虽然非常直观，但它并没有在函数的\emph{定义}中明确提到。因此，我们必须证明这个想法。为了解释这一点，我们将考虑属于关系 $f$ 和 $g$ 的所有有序对。通过证明这些有序对是相同的，我们可以在集合意义上得出 $f = g$。请注意，我们将进行\emph{双重包含}论证！

\begin{proof}
    设 $A, B$ 为集合。并设 $f : A \to B$ 和 $g : A \to B$ 为函数。假设
    \[\forall x \in A \centerdot f(x) = g(x)\]

    首先，我们证明 $f \subseteq g$。给定 $(a,b) \in f$。因为 $f$ 为函数，这意味着 $f(a) = b$。根据主假设，可得 $f(a) = g(a)$，所以 $g(a) = b$。因此 $(a,b) \in g$。这表明
    \[(a, b) \in f \implies (a, b) \in g\]
    因此 $f \subseteq g$。

    接着，我们用相同的方法证明 $g \subseteq f$。给定 $(c,d) \in g$。因为 $g$ 为函数，这意味着 $g(c) = d$。根据主假设，可得 $f(c) = g(c)$，所以 $f(c) = d$。因此 $(c,d) \in f$。这表明
    \[(c, d) \in g \implies (c, d) \in f\]
    因此 $g \subseteq f$。

    由于我们已经证明了 $f \subseteq g$ 和 $g \subseteq f$，我们可以得出结论 $f = g$。
\end{proof}

这为我们提供了一种简便的方法来证明两个函数相等，而不需要深入探讨它们的底层关系或集合结构。我们只需要证明两个函数对于定义域中的每一个元素，其输出是相同的。接下来，我们通过几个例子来说明这一点。\\

\begin{example}
    设 $A = \{-1, 0, 1\}$。定义函数 $f_1 : A \to \mathbb{Z}$ 和 $f_2 : A \to \mathbb{Z}$ 为
    \[\forall x \in A \centerdot \big(f_1(x) = x\big) \land \big(f_2(x) = x^3\big)\]
    我们来证明 $f_1 = f_2$。由于定义域只包含三个元素，我们可以逐一检验输出。
    \begin{align*}
        f_1(-1) = -1 &= (-1)^3 = f_2(-1)\\
        f_1(0) = 0 &= 0^3 = f_2(0)\\
        f_1(1) = 1 &= 1^3 = f_2(1)
    \end{align*}
    因此，对于每一个合法输入（即 $\forall x \in A$）函数 $f_1$ 和 $f_2$ 有相同的输出（即 $f_1(x) = f_2(x)$）。因此 $f_1 = f_2$。
\end{example}

\begin{example}
    设 $B = \{1, 2, 3\}$。定义函数 $g_1 : B \to \mathbb{Z}$ 和 $g_2 : B \to \mathbb{Z}$ 为
    \[\forall n \in B \centerdot \big(g_1(n) = n^3-n^2-6\big) \land \big(g_2(n) = 5n^2-11n\big)\]
    我们来证明 $g_1 = g_2$。定义域还是只有三个元素，所以我们可以手工检验所有相等性。
    \begin{align*}
        g_1(1) &= 1^3 - 1^2 - 6 = 1 - 1 - 6 = -6 \\
        g_2(1) &= 5 \cdot 1^2 - 11 \cdot 1 = 5 - 11 = -6 \\
        \\
        g_1(2) &= 2^3 - 2^2 - 6 = 8 - 4 - 6 = -2 \\
        g_2(2) &= 5 \cdot 2^2 - 11 \cdot 2 = 20 - 22 = -2\\
        \\
        g_1(3) &= 3^3 - 3^2 - 6 = 27 - 9 - 6 = 12 \\
        g_2(3) &= 5 \cdot 3^2 - 11 \cdot 3 = 45 - 33 = 12
    \end{align*}
    因此 $\forall n \in B \centerdot g_1(n) = g_2(n)$，所以 $g_1 = g_2$。
\end{example}

由于这两个例子的定义域都较小，我们可以逐一检查每个元素。然而，并不是所有情况都是如此。有时，我们需要考虑定义域内的任意元素（因为我们要证明的性质是以 ``$\forall$'' 量词开头的），并基于此进行分析。实际上，这个例子有一种有趣的方法可以实现这一点，现在我们就来展示一下它是如何实现的。

给定 $n \in B$。由于 $g_1(n)$ 和 $g_2(n)$ 都属于 $\mathbb{Z}$，我们可以考虑它们的差。具体来说，我们发现
\begin{align*}
    g_1(n) - g_2(n) &= (n^3 - n^2 - 6) - (5n^2 - 11n) \\
    &= n^3 - 6n^2 - 11n - 6 \\
    &= (n - 1)(n - 2)(n - 3)
\end{align*}
（注意：读者可以通过简单地展开这三项的乘积来验证最后的等式。）

由于 $n \in B$，我们知道 $n$ 可能是 $1,2,3$。在每种情况下，其中一项 --- $(n - 1), (n - 2), (n - 3)$ --- 必定为零。因此
\[g_1(n) - g_2(n) = (n - 1)(n - 2)(n - 3) = 0\]
据此，我们得到 $g_1(n) = g_2(n)$。由于这对任意 $n \in B$ 都成立，我们可以得出结论 $g_1 = g_2$。

我们要指出，这比在这个特定例子中``检查所有情况''的方法要复杂得多。我们是怎么知道要关注差的呢？我们又是怎么知道它会这样分解的呢？这正是数学的魅力所在！我们可能通过思考如何解决一个更普遍的问题来找到这种巧妙的方法，因为在这种情况下，定义域太大，根本无法逐一考察每个案例。我们可能会识别出因式分解，或者从 $B = \{1, 2, 3\}$ 这个事实中猜到它。如果你仔细思考，你可能会明白我们是如何想出这个例子的！$\smiley{}$

让我们来看一个更复杂的函数相等的例子。它涉及一些我们假设你不熟悉的概念，我们也不会再次讨论它们，但我们认为这个例子足够有趣和有启发性，所以将其呈现在这里。\\

\begin{example}
    我们将在这里定义两个函数，并说明它们为何相等。设每个函数的定义域和值域为 $\mathbb{R}^2$（实平面）。现在，让我们通过几何方式（即视觉上）来定义两个函数 $F_1$ 和 $F_2$。我们希望 $F_1$ 输入平面上的一个点 $p$，并输出将 $p$ 围绕原点逆时针旋转 $90 \degree$ 后再根据原点镜像得到的点。而 $F_2$ 则是输入点 $p$，并输出将 $p$ 顺时针旋转 $90 \degree$ 后得到的点。为了更好地理解这两个函数的含义，请看以下 $F_1$ 和 $F_2$ 在特定点上的示意图。

    \begin{multicols}{2}
        \begin{center}
            {\begin{tikzpicture}
                \draw[latex-latex] (-3,0) -- (3,0); 
                \draw[latex-latex] (0,-3) -- (0,3); 
                \draw (0,0) -- (1.5,1.5);
                \node at (1.5, 1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, 1.5)}] node[right] {$p$};
                \draw (0,0) -- (-1.5,1.5);
                \node at (-1.5, 1.5)[circle,fill,inner sep=2pt]{};
                \draw[rotate=45] (0,0) rectangle (0.3,0.3);
                \draw (0,0) -- (1.5,-1.5);
                \node at (1.5, -1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, -1.7)}] node[right] {$F_1(p)$};
                \draw[dashed,-latex] (1.5, 1.5) .. controls (0.5, 2.8) and (-0.5, 2.8) .. (-1.4, 1.6);
                \draw[shift={(-0.5, 2.6)}] node[left] {\small 旋转 $90 \degree$};
                \draw[dashed,-latex] (-1.5, 1.5) .. controls (-2, 0) and (-1.5, -2) .. (1.4, -1.6);
                \draw[shift={(-1.0, -0.3)}] node[right] {\small 围绕};
                \draw[shift={(-1.0, -0.7)}] node[right] {\small 原点};
                \draw[shift={(-1.0, -1.1)}] node[right] {\small 镜像};
            \end{tikzpicture}}
        \end{center}

        \begin{center}
            {\begin{tikzpicture}
                \draw[latex-latex] (-3,0) -- (3,0); 
                \draw[latex-latex] (0,-3) -- (0,3); 
                \draw (0,0) -- (1.5,1.5);
                \node at (1.5, 1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, 1.5)}] node[right] {$p$};
                \draw (0,0) -- (1.5,-1.5);
                \node at (1.5, -1.5)[circle,fill,inner sep=2pt]{};
                \draw[shift={(1.6, -1.7)}] node[right] {$F_2(p)$};
                \draw[rotate=-45] (0,0) rectangle (0.3,0.3);
                \draw[dashed,-latex] (1.5, 1.5) .. controls (2.8, 0.5) and (2.8, -0.5) .. (1.6, -1.4);
                \draw[shift={(0.7, 0.3)}] node[right] {\small 旋转 $90 \degree$};
            \end{tikzpicture}}
        \end{center}
    \end{multicols}

    我们声称在函数意义上 $F_1 = F_2$，是相等的。通过尝试几个例子，我们可以发现这可能是真的；也就是说，我们无法找到反例，甚至你可能已经``看出''为什么它是真的。但这些都不是严格的证明。这只是理解某事的一种直观方法。为了严格证明这个事实，我们需要使用一些超出本课程范围的数学工具和方法。由于这个原因，我们实际上只会概述这个证明，并将一些技术细节留给感兴趣的读者去探索。

    主要思想是这样的：我们可以用\emph{向量}表示平面上的点，用\emph{矩阵}表示函数，并通过矩阵乘法来表示函数对点的作用。如果你对矩阵或向量不太了解，不用担心；你可以跳过这个例子，不会错过任何重要内容！不过，如果你想继续了解，我们可以这样解释：矩阵其实就是实数数组，而向量则是只有一列的矩阵。例如，实数平面上的点 $(1, 1)$ 可以用向量 $\begin{bmatrix}
        1 \\
        1
     \end{bmatrix}$ 表示。向量的\emph{旋转}可以通过\emph{旋转矩阵}来实现。（你可能在中级物理课程中学到过，比如电磁学或力学。）例如，逆时针旋转 $90 \degree$ 可以用下面这个特定的矩阵来表示
     \[\begin{bmatrix}
        0 & -1 \\
        1 & 0
     \end{bmatrix}\]
     将点 $(a, b)$ 逆时针旋转 $90 \degree$，相当于将对应的向量与这个矩阵相乘，遵循常规矩阵乘法规则（即将左边的行与右边的列对应元素相乘并相加）。例如，我们来旋转点 $(1, 1)$：
     \[\begin{bmatrix}
        0 & -1 \\
        1 & 0
     \end{bmatrix}\begin{bmatrix}
        1 \\
        1
     \end{bmatrix} = \begin{bmatrix}
        0+(-1) \\
        1+0
     \end{bmatrix}=\begin{bmatrix}
        -1 \\
        1
     \end{bmatrix}\]
     看看这结果，正如我们预期的一样！请参阅上面的图片，了解这个旋转的实际效果。

     同理，我们可以通过下面的矩阵表示顺时针旋转 $90 \degree$：
     \[\begin{bmatrix}
        0 & 1 \\
        -1 & 0
     \end{bmatrix}\]
     （注意这些项中的相似之处。这是有原因的，我们建议你通过搜索引擎来找到原因。）

    以原点为中心的镜像也可以通过矩阵乘法来表示，但有一种更简单的方法来理解它：只需将两个坐标都变成它们的相反数。例如，以原点为中心镜像 $(-1, 1)$ 会变成 $(1, -1)$。

    这使我们能够完全表示 $F_1$ 和 $F_2$ 的动作。由于 $F_1$ 表示``逆时针旋转 $90 \degree$ 并将两个坐标取反''，我们可以写成
    \[F_1\Bigg(\begin{bmatrix}
        a \\
        b
     \end{bmatrix}\Bigg) = -\begin{bmatrix}
        0 & -1 \\
        1 & 0
     \end{bmatrix}\begin{bmatrix}
        a \\
        b
     \end{bmatrix}=\begin{bmatrix}
        b \\
        -a
     \end{bmatrix}\]
     （前面的负号用于去反），由于 $F_2$ 表示``顺时针旋转 $90 \degree$''，我们可以写成
     \[F_2\Bigg(\begin{bmatrix}
        a \\
        b
     \end{bmatrix}\Bigg) = \begin{bmatrix}
        0 & 1 \\
        -1 & 0
     \end{bmatrix}\begin{bmatrix}
        a \\
        b
     \end{bmatrix}=\begin{bmatrix}
        b \\
        -a
     \end{bmatrix}\]
     按照矩阵和向量的乘法规则，我们可以很容易地看到这两个表达式对于任意 $a$ 和 $b$ 都是相等的。因此，假设你对旋转矩阵有一些了解，这就证明了 $F_1 = F_2$！
\end{example}