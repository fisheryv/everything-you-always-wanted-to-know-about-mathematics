% !TeX root = ../../../book.tex

\subsection{基本计数对象及公式}

\psset{inline=symbol, colorset=2c}

让我们回到之前讨论的扑克牌型计数问题。我们关心每种牌型出现的次数，以及从一副新洗好的 $52$ 张牌中拿到同花的具体方式有多少种。首先，我们可以从一个更简单的问题入手：总共有多少种不同的牌型？换句话说，有多少种方法可以排列整副 $52$ 张牌？更进一步，在这些排列中，有多少种会使前 $5$ 张牌构成特定的牌型？也就是说，我们想要找出所有不同的洗牌方式；我们称之为\emph{打乱}。接下来，考虑一种特定的牌型，例如 \tenc \Jc \Qc \Kc \Ac，并计算有多少种洗牌方式使得前 $5$ 张牌恰好构成该牌型（因为我们不关心这 $5$ 张牌的顺序，只关注最终手牌的组合）。

我们有哪些工具可用？事实上，我们只有加法原理和乘法原理。除此之外，还可以借助数学的洞察与直觉。那么，让我们开始吧。洗牌过程与分步或多步处理有什么联系呢？有趣的是，我们实际上并不关心洗牌的具体过程，只关注最终可能的结果数量。那么，一副牌最关键的特征是什么？没错，是牌从上到下的顺序。基于这一点，我们可以通过确定每张牌的位置来构造任意一种排列。

我们可以这样洗牌：手持一副牌，依次将牌面朝下放置在面前的牌堆上。第一步，手中有 $52$ 张牌可选，牌堆尚未形成，因此有 $52$ 种选择。第二步，无论第一张牌是什么，手中仍剩 $51$ 张牌可供选择。（记住：这是乘法原理的关键——每一步的选择数不依赖于之前的具体选择。）第三步，手中剩下 $50$ 张牌，依此类推。直到第 $52$ 步，手中仅剩 $1$ 张牌，将其放在桌上已有的 $51$ 张牌堆之上。完成所有步骤后，我们得到一副洗好的牌，牌面朝下堆叠。第一步的牌位于最底部，最后一步的牌位于最顶部。此外，我们发现对于任意一种洗牌结果，\emph{有且仅有}一个选择序列能够产生该结果。（这满足了乘法原理的另一个条件，即不同序列对应不同结果。请仔细思考为什么这一点是必要的。）

以上观察使我们能够直接运用乘法原理来回答这个问题：一副标准扑克牌有多少种不同的排列方式？答案是……
\[52 \cdot 51 \cdot 50 \cdot \dots \cdot 3 \cdot 2 \cdot 1 = \prod_{k \in [52]} k = 8.06581752 \times 10^{67}\]
哇塞！这真是一个天文数字。相比之下，阿伏伽德罗常数\footnote{阿伏伽德罗常数 (Avogadro Constant) 是一个重要的物理常数，其数值为 $6.02214076 \times 10^{23} $ mol$^{-1}$，表示一摩尔物质中所含的基本粒子数量。}仅约为 $10^{23}$。对于这类连乘运算，我们有一种更简洁的表示方法，即``将所有从 $52$ 到 $1$ 的自然数相乘''。你可能之前见过这种表示，现在我们来正式定义它。

\begin{definition}
    设 $n \in \mathbb{N}$。自然数 $n!$ 读作 $n$ 的\dotuline{阶乘}，定义为
    \[n! = \prod_{k \in [n]} k = k \cdot (k - 1) \cdot (k - 2) \cdot \dots \cdot 3 \cdot 2 \cdot 1\]
    定义 $0!=1$。
\end{definition}
（回想一下，我们在 \ref{sec:section2.5.1} 节中利用归纳原理编写递归程序计算阶乘的例子。不妨重温一下那一节的内容！）

现在来思考一下我们实际上完成了什么。在这个例子中，数字 $52$ 有什么特殊吗？除了它代表一副牌的数量之外，并无特别之处！假设我们问：有多少种方法将 $[n]$ 中的元素排成有序列表？若将 $n$ 取 $52$，这便与之前的问题完全相同！（我们可以在牌的集合与 $[52]$ 之间建立自然的双射关系。你能做到吗？你是否理解这两个问题的等价性？）

\subsubsection*{全排列}

这类问题——即有多少种方法将 $n$ 个对象排列成一个有序列序列——非常常见，因此我们为这些有序列序列定义了一个专门的术语。我们使用\emph{函数}的术语来严格定义它们，但请注意它们与其他数学对象（如序列序列）之间的联系。

\begin{definition}
    设 $n \in \mathbb{N}$。$[n]$ 的\dotuline{全排列 (Permutation)}是一个双射函数 $f : [n] \to [n]$。

    换言之，$[n]$ 的全排列是 $[n]$ 中元素的一个有序 $n$ 元组，其中每个元素恰好出现一次。
\end{definition}

\begin{proposition} \label{prop:proposition8.2.14}
    设 $n \in \mathbb{N}$，$S$ 为 $[n]$ 上所有排列的集合，则 $|S| = n!$。
\end{proposition}

\begin{proof}
    我们可以通过依次选择每个位置上的元素来构造 $[n]$ 的任意排列。首先，从 $n$ 个元素中选择一个作为第一个元素；接着，从剩余的 $n-1$ 个元素中选择一个作为第二个元素；一般地，在第 $k$ 步时，我们从 $n-k+1$ 个未被选择的元素中选取一个作为第 $k$ 个位置的元素。这一过程持续到第 $n$ 步，此时只剩下一个元素可选。根据 ROP，总共有 $n(n-1)(n-2) \dots 2 \cdot 1 = n!$ 种不同的排列方式。
\end{proof}
（注意：这也解释了为什么我们将 $0!$ 定义为 $1$。因为 $n!$ 表示排列 $n$ 个对象的方法数，而空集的排列只有一种方式——即空排列——因此 $0! = 1$ 是合理的。在后续定义\emph{二项式系数}时，这一概念会再次出现；在相关公式中，$0! = 1$ 将非常有用。）

\subsubsection*{选择}

这一结论从数学上证实了我们关于洗牌现象的一般观察，并将我们向扑克牌型排名问题的答案推进了一步。我们想要确定的是，有多少种不同的洗牌方式能够在前五张牌中形成特定牌型的五张手牌。为了更好地理解这一问题，我们不妨从一个更普遍的情形入手。假设我们有一组特定的牌型，例如 \tenc \Jc \Qc \Kc \Ac，接下来我们将计算有多少种洗牌方式能够将这组特定的牌置于牌堆的前五张。

这种情况是如何实现的呢？我们并不关心手牌中五张牌的顺序，也不关心其余 $47$ 张牌的排列方式。关键在于这五张特定的牌是否出现在牌堆的最上方。因此，我们可以沿用之前的思路，构建一种满足这一条件的洗牌方法。为了运用乘法原理，我们需要设计一个具体的操作流程。具体该怎么做呢？

实际上，我们只需满足两个条件，因此可以设计一个包含两个步骤的过程。第一步，将不在手牌中的 $47$ 张牌以任意顺序排列在牌堆的底部；第二步，将手牌中的五张牌以任意顺序放置在牌堆的顶部。这里适用乘法原理，因为无论底部的 $47$ 张牌如何排列，都不会影响顶部五张牌的排列方式。（需要注意的是，在应用乘法原理之前，必须理解其在该情境下的适用性——这一点往往微妙且不易察觉！）接下来，我们只需分别计算每一步的排列方式数量即可。

实际上，我们只需要满足两个条件，所以可以设计一个两步过程来确保这些条件成立。第一步，把不在手牌中的 $47$ 张牌按某种顺序放在牌堆底部。第二步，把手牌中的五张牌按某种顺序放在牌堆顶部。这里适用乘法原理，因为无论如何排列底部的 $47$ 张牌，都不会影响我们排列顶部五张牌的方式。（一般来说，在应用乘法原理之前，要理解为什么在特定情况下适用；这通常是微妙且不明显的！）现在，我们只需要计算每一步的排列方式即可。

第一步是对 $47$ 张牌进行排列。根据命题 \ref{prop:proposition8.2.14}，共有 $47!$ 种排列方式。

第二步是对五张牌进行排列。根据命题 \ref{prop:proposition8.2.14}，共有 $5!$ 种排列方式。

于是，根据乘法原理，依次完成这两步的总排列方式为 $47! \cdot 5!$。问题就此解决！

我们选择的 \tenc \Jc \Qc \Kc \Ac 有什么特殊吗？完全没有！我们可以再次运用乘法原理，从中获取更多关于洗牌数量的信息。具体来说，设 $X$ 为从牌堆中选择五张牌作为手牌的方式数目。现在考虑一个三步过程：首先选出五张特定的牌，然后以某种顺序排列它们，最后将剩下的 $47$ 张牌排列在下方。这里同样适用乘法原理，因为每一步的排列方式不受前一步选择的影响。此外，任何一种洗牌方式都可以通过这一过程唯一确定。（请思考为什么这是正确的。对于任意一种洗牌方式，最上面的五张牌决定了第一步所选的手牌，它们的排列顺序决定了第二步的执行方式，而其余牌的排列则决定了第三步的执行方式。）因此，我们得到了计算同一组对象（即所有洗牌方式）的两种表达式，于是必然有：
\[X \cdot 5! \cdot 47! = 52!\]
从而可得：
\[X = \frac{52!}{5! \cdot 47!}\]
让我们思考一下这个公式的含义。这里 $X$ 表示从 $52$ 张牌中选出 $5$ 张牌的方式数目。数字 $5$ 和 $52$ 有什么特别之处吗？答案是没有！实际上，我们推导出了一个通用公式，用于计算从更大集合中选出任意数量对象的方法数。尽管表面看来不尽相同，但我们已经非常接近扑克手牌问题的最终答案了。在彻底解决这个问题之前，让我们先进行一番进一步的讨论。

首先，我们刚才使用的论证类型是组合数学中非常常见且有用的证明技术，称为\emph{双法计数}。具体来说，我们选定一组特定对象——在本例中，即一副牌的洗牌方式——然后通过两种不同的方法计算该集合的大小。每种方法都得出了一个不同的公式，但由于我们计数的是同一个对象集合，因此这些公式必然相等。我们将在 \ref{sec:section8.4} 节中更详细地探讨这种论证类型，并给出更多例子。目前，我们希望你能理解这种论证方式的有效性，尤其是我们希望你用它来证明下面的命题 \ref{prop:proposition8.2.16}。在此过程中，你将推广我们这里提出的论证。为了阐明这一点，让我们总结一下刚才的工作：

\emph{论证总结}：我们希望找到从 $52$ 张牌中抽取 $5$ 张牌的方法数量 $N$，并推导其表达式。我们将建立两个涉及 $N$ 的不同公式，然后通过求解这些代数表达式得到 $N$ 的公式。

\begin{enumerate}[label=(\arabic*)]
    \item 选择任意一组固定的五张手牌。我们计算洗牌后前五张牌恰好是这组手牌的方法数量。

          注意，这一步对应 $N$ 种可能，我们需要找到 $N$ 的表达式。
    \item 计算全部 $52$ 张牌的排列数量。
    \item 计算前五张牌为固定手牌的排列数量。具体步骤如下：
          \begin{enumerate}[label=(\roman*)]
              \item 计算这五张手牌的排列数量。
              \item 计算剩余 $47$ 张牌的排列数量。
              \item 计算将这五张排列好的牌放在那 $47$ 张排列好的牌上方的方法数量。\\（注意：虽然只有一种方法，但指出这一步骤很重要。）
          \end{enumerate}
    \item 综上，我们用两种不同方法计算同一副牌的排列数量（即洗牌方式），因此它们的结果必然相等。
    \item 通过简化 $N$ 的表达式，得到 $N$ 的公式。
\end{enumerate}
现在，让我们推广刚才推导的公式。首先，我们给出一个定义并引入符号，然后再陈述通用公式。

\begin{definition}
    设 $k, n \in \mathbb{N}$ 且 $n \ge k$。从 $[n]$ 中选取 $k$ 个元素的无序集合称为 \dotuline{$k$-选择}。

    $[n]$ 中 $k$-选择的数量用 ${n \choose k}$ 表示，称为\dotuline{二项式系数}，读作``$n$ 选 $k$''。
\end{definition}

\begin{proposition}\label{prop:proposition8.2.16}
    设 $k, n \in \mathbb{N}$ 且 $n \ge k$。则 $[n]$ 中 $k$-选择的数量为
    \[{n \choose k} = \frac{n!}{k! \cdot (n-k)!}\]
\end{proposition}

\begin{proof}
    留作 \ref{sec:section8.2.4} 节练习 \ref{exc:exercises8.2.2}。
\end{proof}

\subsubsection*{二项式系数}

上述公式可能令你感到惊讶，因为无论 $k$ 和 $n$ 取何值，这里的分数实际上总是一个自然数！这是因为它表示完成某个过程的方法数，正如证明所示，它必须是一个自然数。

我们想指出一个你可能未曾考虑到的特殊情况：当 $k = 0$ 时，${n \choose 0}$ 是多少？你可能会惊讶地发现 ${n \choose 0} = 1$。这为什么合理呢？直观上，我们将 ${n \choose k}$ 理解为从 $n$ 个对象中选择 $k$ 个对象的方法数。那么，从 $3$ 个对象中选择 $0$ 个对象有多少种方式呢？假设桌上有 $3$ 支笔，不选择任何一支。没错，什么都不做！这就是选择 $0$ 个对象的一种方式——也是唯一一种方式。当 $n = 0$ 时，相同论证也同样适用：桌上没有笔，不选择任何一支。看！仍然什么都不需要做。因此，
\[\forall n \in \mathbb{N} \cup \{0\} \centerdot {n \choose 0}=1\]
关于这个结果，还有``更好''、更数学的解释，我们将在下一节证明帕斯卡恒等式 (Pascal's Identity) 时详细说明。目前，我们希望这种启发式的解释能够帮助你理解并接受这一结果。

另一个事实是，当 $k > n$ 时，${n \choose k} = 0$。这是因为从仅有 $3$ 个对象的集合中选择 $5$ 个对象是不可能的。通过之前的推导可以证明这一点：在某个步骤中，如果尝试从一副牌中抽取比实际牌数更多的牌，这是不可能的，因此结果为 $0$。随后，当我们应用 ROP 时，乘积的结果也将是 $0$。

如果你尝试一些 $k$ 和 $n$ 的值，会发现 ${n \choose k}$ 的值呈现所谓的\textbf{单峰分布}。也就是说，固定 $n$ 并让 $k$ 从 $0$ 增加到 $n$，这些值先上升，在 $\lfloor\frac{n}{2}\rfloor$ 和 $\lceil\frac{n}{2}\rceil$ 处达到峰值（如果 $n$ 为偶数，则两者相同），然后下降。此外，该分布是\emph{中心对称的}！你能证明这些性质吗？试试看吧！

\subsubsection*{排列}

现在我们已经掌握了计算扑克牌组合（以及许多其他对象）所需的所有工具。我们知道如何对一个集合的元素进行排列，也知道如何从较大的集合中选择特定大小的子集。利用这两个工具，我们可以计算任意牌型组合。例如，若要计算扑克牌的一个\emph{有序}子集，我们可以先计算选择该子集的方式，再对其元素进行排列，并将乘法原理应用于这一两步过程。事实上，这一思想非常常见，因此我们为它专门命名。

\begin{definition}
    设 $k, n \in \mathbb{N}$ 且 $n \ge k$。从 $[n]$ 中选取 $k$ 个不重复元素组成有序 $k$ 元组称为\dotuline{$k$-排列}。

    换言之，从 $[n]$ 中选取的 $k$-排列是一个单射函数 $f : [k] \to [n]$。
\end{definition}

\begin{proposition}\label{prop:proposition8.2.18}
    设 $k, n \in \mathbb{N}$ 且 $n \ge k$。则 $[n]$ 中 $k$-排列的数量为
    \[{n \choose k} \cdot k! = \frac{n!}{(n-k)!}\]
\end{proposition}

\begin{proof}
    留作 \ref{sec:section8.2.4} 节练习 \ref{exc:exercises8.2.3}。
\end{proof}

\subsubsection*{重复}

在继续讨论扑克牌牌型的计数之前，需要指出的是，本节介绍的所有标准计数公式都假设对象不可\emph{重复}。也就是说，当我们从一副牌中选出五张牌时，不能出现两张相同的牌，例如两张 \Ac 。但在某些情况下，我们允许对象重复出现。回顾上一节的车牌示例，我们可以重复使用数字或字母，例如 \verb|111AAA| 是一个有效的车牌。下面再看一个例子：

\begin{example}
    考虑一枚标准、公平的双面硬币。连续投掷硬币 $6$ 次，记录每次的结果，用 \verb|H| 或 \verb|T| 表示每次投掷的结果。

    \emph{问题}: 有多少种可能的结果？

    要回答这个问题，我们注意到每次投掷硬币都有 $2$ 种可能的结果，且每次的结果都独立于之前的投掷。因此，根据乘法原理，可以计算出总结果为 $2 \times 2 \times 2 \times 2 \times 2 \times 2 = 2^6 = 64$ 种。
\end{example}

这一思想与选择和排列相关，因为除了使用乘法原理，我们还可以将这些序列视为从集合 $\{\verb|H|, \verb|T|\}$ 中选取 $6$ 个对象的排列，其中对象可以重复出现。（注意 $\{\verb|H|, \verb|T|\}$ 与 $[2]$ 之间存在自然的对应关系，这相当于排列 $[2]$ 中的 $6$ 个对象，并允许重复。）

这一概念通过以下定义表达：

\begin{definition}
    设 $k, n \in \mathbb{N}$。从 $[n]$ 中选取 $k$ 个可重复元素组成有序 $k$ 元组称为\dotuline{可重复 $k$-排列}。
\end{definition}

注意，此处对 $k$ 没有任何限制，因为我们允许元素重复出现。在之前的不重复 $k$-排列中，若不允许重复，则从 $8$ 个对象中选取 $10$ 个对象是无意义的！但在此处，这是允许的，因此 $k$ 和 $n$ 可以是任意自然数。

\begin{proposition}\label{prop:proposition8.2.21}
    设 $k, n \in \mathbb{N}$。则 $[n]$ 中可重复 $k$-排列的数量为 $n^k$。
\end{proposition}

\begin{proof}
    留作 \ref{sec:section8.2.4} 节练习 \ref{exc:exercises8.2.4}。
\end{proof}

你可能会期望看到关于可重复 $k$-选择的定义和命题。我们将在 \ref{sec:section8.5} 节讨论这些内容，但由于计数这类选择的方法更为复杂，我们将留待后续详细说明。

\subsubsection*{计数公式总结}\label{sec:section8.2.3}

我们来总结一下已定义和推导的标准计数对象与公式：假设有 $n$ 个对象，要从中选择 $k$ 个，共有多少种选择方法？这取决于两个关键问题：
\begin{itemize}
    \item 是否允许重复？
    \item 顺序是否重要？
\end{itemize}
每个问题的答案只能是``\verb|是|''或``\verb|否|''，不同的答案对应不同的计数公式。
\begin{center}
    \tikzstyle{decision} = [diamond, aspect = 3, text centered, draw=black, fill = green!30]
    \tikzstyle{process} = [rectangle, minimum width=2.1cm, minimum height=1.35cm, text centered, draw=black, fill = yellow!50]
    \tikzstyle{arrow} = [->,>=stealth]
    \begin{tikzpicture}[thick, scale=0.3]
        \node (dec1) [decision] at (0, 0) {允许重复吗？};
        \node (dec2) [decision] at (-14, -6) {顺序重要吗？};
        \node (dec3) [decision] at (14, -6) {顺序重要吗？};
        \node (form1) [process] at (-23, -12) {$n^k$};
        \node (form2) [process] at (-5, -12) {???};
        \node (form3) [process] at (5, -12) {$\displaystyle \frac{n!}{(n-k)!}$};
        \node (form4) [process] at (23, -12) {$\displaystyle {n \choose k}$};
        \draw [arrow] (dec1) -|node [above] {Y} (dec2);
        \draw [arrow] (dec1) -|node [above] {N} (dec3);
        \draw [arrow] (dec2) -|node [above] {Y} (form1);
        \draw [arrow] (dec2) -|node [above] {N} (form2);
        \draw [arrow] (dec3) -|node [above] {Y} (form3);
        \draw [arrow] (dec3) -|node [above] {N} (form4);
    \end{tikzpicture}
\end{center}
（注意：有时问题中 $n$ 和 $k$ 的角色可能互换，这一点需要特别留意！我们会尽量遵循常用约定，但总体来说，字母本身并不重要，重要的是理解字母所代表的含义。）

\subsubsection*{组合数学的函数定义}

记住这些计数方法在\emph{函数}视角下的等价表述会很有帮助。用函数来重新表述问题，往往能提供新的解决思路。至少，这是一种有益的思维训练，例如能帮助你理解\emph{全排列}和\emph{双射}之间的关系。下面我们列出这些表述及对应公式，希望你能主动思考这些内容。尝试理解概念之间的关联，向只熟悉一种解释的朋友讲解，或与同学讨论以发掘不同的表述方式！

\begin{itemize}
    \item $n$ 个元素的\textbf{全排列}是双射函数 $f : [n] \to [n]$。\\
          从集合 $[n]$ 到其自身共有 $n!$ 种可能的双射。
    \item 从 $n$ 个元素中选择 $k$ 个元素的\textbf{排列}是单射函数 $f : [k] \to [n]$。\\
          从 $[k]$ 到 $[n]$ 共有 $\frac{n!}{(n-k)!}$ 种可能的单射。
    \item 从 $n$ 个元素中选择 $k$ 个元素的\textbf{可重复排列}是函数 $f : [k] \to [n]$。 \\
          从 $[k]$ 到 $[n]$ 共有 $n^k$ 种可能的函数。
\end{itemize}